Google Drive Clone
2:12:22
go. Do you think you need to invent the new Facebook to get hired? Not at all.
2:12:27
You just have to prove that you can build professional and productionready applications that solve real problems
2:12:34
and that won't crash harder than your last relationship. So, hi there and welcome to a course in which I'll teach
2:12:40
you how to build store it, a storage management solution inspired by giants
2:12:46
like Google Drive, Dropbox, and One Drive used by billions of users. But
2:12:51
here's the kicker. You won't just slap together a bunch of features. You'll also learn a modern, state-of-the-art
2:12:58
tech stack along the way. Together, we'll create this project using the latest and greatest next 15, which
2:13:04
updates faster than you can keep up. So, buckle up because in this tutorial, you'll learn how to implement secure
2:13:12
passwordless OTP authentication. Build a streamlined dashboard to track storage
2:13:17
and recent uploads. Manage multifile uploads in different file types. Rename,
2:13:22
preview, download, delete, and even share access with others. Use global search to find any file instantly, and
2:13:29
design a responsive UI that works flawlessly on any device. And much more,
2:13:34
covering the Nex.js foundations, best practices, architecture, and top-notch performance. This isn't just another
2:13:41
app. It's a step-by-step hands-on experience allowing you to showcase your essential job ready skills. And if that
2:13:49
doesn't get your adrenaline pumping, I don't know what will. But if you're ready, let's dive right in. If you visit
2:13:54
the website, you'll be redirected to the O pages since you don't have an account. You can log in or create a new account.
2:14:01
Right after providing that account info, you'll be prompted to provide a one-time password. So, let's head over back to
2:14:07
our email. And there it is. Let me type it in. And I'm in. We have a beautiful screen that shows the storage usage,
2:14:14
different categories of files, recent uploads on the right, navigation on the left, and a global search bar at the top
2:14:21
that allows you to search any file you've uploaded lightning fast. There's also an upload button at the top right.
2:14:27
Click it and you can upload any kind of file from documents, images, or media. You can also upload multiple files at
2:14:34
the same time. Upon a successful upload, you'll see changes in storage usage and files being automatically categorized in
2:14:40
different sections. Let's navigate to the specific file categories to see their dedicated space usage, filter them
2:14:46
or do the pagionation. And the same thing goes for all the other categories of files. You can also perform different
2:14:52
kinds of operations on each file. So let's rename this to something else or even check its details. If you click on
2:14:59
it, you'll see this file in the preview. For PDFs, you will see a preview in the default browser PDF Reviewer. Pretty
2:15:06
cool, right? From the drop down, you can also download these files and save them to your device or simply delete them.
2:15:12
But that's not even the best part. You can actually share these files with others. That's right. Let's click share,
2:15:18
provide an email, open an account using that email, and there you go. The shared file is already there. You can do
2:15:24
anything you want with it if needed. You can also restrict the shared actions. And as always, the whole thing is
2:15:30
completely mobile responsive, working on any device that you could have, even that teeny tiny Galaxy Zfold. So think
2:15:37
about it. This single project showcases everything a full stack developer needs to know from back-end architecture,
2:15:44
database design and authentication flows to file handling, user permissions, modern UIX principles, and even web
2:15:51
vitals using Nex.js, JS, TypeScript, Tailwind CSS, ChatcN Charts, and
2:15:57
AppRight, an open-source backend as a service that gives us complete control over our data with many self-hosting
2:16:04
options and powerful APIs that some other alternatives don't offer. Now, let's build something that actually
2:16:10
matters. Not because it's revolutionary, but because it's exactly what the companies need. So without any further
2:16:16
ado, let's dive right in. To get started building a great
2:16:22
project, we'll start from bare beginnings. In this case, I'll be using WebStorm. It is a professional IDE that
2:16:29
just recently became completely free for non-commercial use. While recording this
2:16:35
application, some of the dependencies changed a bit. It's not a big difference from a feature perspective, but it's a
2:16:41
difference in a way these things have to be written. The concept stays the same. It's just the setup syntax that differs
2:16:47
a bit. Click on the use this template at the top when you click the link down in the description and then choose one
2:16:54
option to move forward. For example, create a new repo or open it in Codespace. Once you do that, you can
2:16:59
either continue working in Codespace or clone it on your machine. Everything stays the same moving forward. I
2:17:05
provided all the needed dependencies in this template so you don't have to install anything ahead of time. You can
2:17:10
skip that part whenever I mention it. the rest will flow smoothly so you can actually get started quickly and start
2:17:16
learning what matters from tsconfigs to tailing configurations package jsons containing different versions of
2:17:22
dependencies we're using to the public folder with the assets and then finally the app folder within which we'll
2:17:29
develop our code in this case I won't go too deep into what each one of these files does but what I will do is leave a
2:17:37
link down in the description covering the exact timestamp to my NexJS15 15
2:17:42
crash course which is released on YouTube for free where I dive into a deep explanation of each one of these
2:17:48
files and more in case you need a refresher on how NextJS applications work considering that this application
2:17:55
right here will also be a Nex.js application. So I'll leave a link to this video down below and I'll also
2:18:01
leave a link down below to our ultimate Nex.js course. The only course you need
2:18:06
if you truly want to dive into the production level of writing NexJS code. And since you're watching this video, I
2:18:12
think that's exactly what you want to do. Specifically talking about caching, different runtimes, client versus server
2:18:18
rendering, different data fetching methods, and more. Just recently, I updated it to the latest versions, the
2:18:25
best performance, detailed theoretical explanations, and even active lessons so that you can truly test your knowledge
2:18:31
and try to do something before you watch a video lecture, which is not the case here on YouTube as you can just
2:18:37
sometimes follow along and it feels like you're watching Netflix. But in this case, you'll truly have to test your
2:18:43
knowledge before you can watch the next lesson. And why am I saying all of this? Because from this point onward, I will
2:18:49
assume that you have either watched the free NexJS5 crash course so I don't have to overexlain some things that I've
2:18:56
already mentioned there or the paid one if you can afford it and you really want to learn how it works under the hood. So
2:19:02
with that said, let's go ahead and run our application by running mpm rundev
2:19:07
which will start development server on localhost 3000. Commandclick it to open
2:19:12
it up and it'll look something like this. you'll get next.js's boilerplate code. What you can notice is that the
2:19:18
title will say create next app. So, let me show you how you can update it to make more sense with what we are
2:19:24
building. I'll head over to app and layout.tsx. As you can see here, we have
2:19:29
our nextgs metadata that allows us to change our title. In this case, we can change it to store it. And for the
2:19:37
description, we can say something like store it the only storage solution you
2:19:42
need. Alongside that, we can also update our fonts. So in this case, instead of
2:19:47
getting the gist sans, I'll go ahead and remove those two. And instead, I'll say
2:19:53
const poppins is equal to poppins. I'll call it and provide the options object.
2:19:58
And we can import the poppins font like this from next
2:20:03
slashfont slash Google. Within it, we can pass the subsets. In this case, that
2:20:09
will be equal to Latin. We can also pass weight. We'll need all of the weights in
2:20:15
this case, ranging from 100 all the way to 900. And finally, we can specify the
2:20:21
variable that we'll use to define this font. It'll be d-font dash poppins.
2:20:27
There we go. We can remove this import and place this right here at the top. And now we can use this font right here
2:20:34
in the body. So let's head over to the class name and let's just use a singular
2:20:39
font which is going to be a class name of a template string popins do variable
2:20:46
with font-pins and we can keep this anti-alias class name as it typically
2:20:53
helps to make some fonts appear more readable. Now the font will have changed and so did the title but as you can see
2:20:59
the favicon remained the same. So, let's get the new and updated one, and we'll get it from our Figma file, which means
2:21:06
that the link to the complete design of this project will be down in the description. You can get it completely
2:21:11
for free. So, if you want to, you can maybe pause this video and sometimes try to build some of the things on your own
2:21:18
and then see how I would approach them for the best solution. You would kind of be replicating what we're doing with
2:21:23
active lessons within the ultimate next.js GS course, but it will be just a bit tougher as in our active lessons, I
2:21:30
actually explain each task in detail to guide you on how I would approach thinking about implementing a specific
2:21:36
task, giving you some examples as well as resources and documentation pages that you can refer to. And finally, a
2:21:44
complete hint if you cannot manage to do it on your own to try to do it, but just
2:21:49
with a bit of help. If you would be replicating all of that just from the design, it would be a bit tougher, but
2:21:54
you can still do it. In any case, once you're in design, you will be able to find something that looks like this
2:22:00
where you have a logo and then you can just export it. In this case, I'll go with a JPEG. Once you download it, head
2:22:08
over to Favicon Generator and I'll turn that image right here into an ICO, an
2:22:13
icon file. You can do that by simply uploading this icon right here. And immediately it will give you a favicon
2:22:19
version of that which you can simply drag and drop into the app folder which will ask you to override the existing
2:22:26
one. So override it. And there we go. Now if we go back to the website you can
2:22:31
see that all of our website's metadata such as the title of store it and then our favicon nicely appear right here.
2:22:38
That means that soon enough we'll be able to start focusing on the codebase. But before that, let's set up
2:22:44
linting. To make sure that you follow all the best practices in your codebase and keep your code clean, we'll go ahead
2:22:51
and set up eslint right here before we start writing any code to make sure that your code is clean and so that you can
2:22:58
quickly find problems if they appear. Now, eslint is a llinter, but I'll also teach you how to hook it up with
2:23:04
prettier, which is an opinionated code formatter. together they'll do wonders and just make sure that your codebase is
2:23:11
clean. So let's open up our terminal and I'll create a new one so we can run some
2:23:16
additional commands while our application is running. And I'll run mpm
2:23:21
install eslint-config-standard eslint- plug-in-
2:23:28
tailwind CSS which will help us with adding Tailwind CSS classes a lot and
2:23:35
eslint-config prettier. Finally, we'll need the prettier itself, which is an additional package. And all of these can
2:23:42
be saved as dev dependencies. So, just at the start, I'll say mpm
2:23:47
install--save-dev, which is going to save them as dev dependencies. And I notice I have a typo right here, eslint
2:23:54
plugin tail css. Fix it, and press enter. It's going to install them in
2:24:00
less than a second, which means that we can now head over to our eslint rc.json, JSON which was generated for us by
2:24:08
Nex.js. And here we can make sure that all of the rules of the packages and plugins we just installed are being
2:24:14
followed by adding them to the extents list. So we can say next core web
2:24:20
vital. Then we can say next typescript. We have standard and we can also add a
2:24:29
plug-in tailwind CSS/recommended. And finally, we have
2:24:34
the prettier package as well. Now, if you're using WebStorm, you might press commandshiftp and then search for
2:24:42
prettier, go to preferences, and turn on manual prettier configuration, which is
2:24:48
going to take it right here from your node modules. And you can run reformat and run on save. Okay, great. And you
2:24:55
can repeat the same thing with ESLint by searching for it, turning on the manual configuration, point it to your node
2:25:03
modules, and run the save on fix. And if you're in VS Code, you might need to create a new folder called VS Code and
2:25:11
within it a settings.json file, which is going to have some kind of a setting that says editor code actions on save
2:25:18
source fix all ESLint explicit, which will make sure to turn on the ESLint configuration on save. And this is also
2:25:25
something that we dive a bit deeper into within our nextgs course where we have a completely separated video on eslint and
2:25:32
prettier setup with all the configurations. With that said, we can test whether it works by heading over to
2:25:38
page.tsx and make any kind of change to a file like adding a space and then save the file. You'll notice that immediately
2:25:45
it'll make some small changes with the class names to fix some eslint rules. Later on, you can notice that it'll be
2:25:51
doing many more things like fixing some spacing within your application and just making sure that everything looks
2:25:57
consistent whenever you save a file. Now, let's clean this page up because we
2:26:03
don't need anything within it. This is going to be our homepage. So, I'll only have one div within which I'll have an
2:26:09
H1 that'll say store it. The only storage solution you need. I'll also
2:26:14
give it a class name equal to text-3xl just so we can nicely see it in
2:26:21
the browser. There we go. This is looking good. With this in place, we are ready to implement our design system.
2:26:28
We'll do that by figuring out some of the specific elements of the theme of our application. In the style guide,
2:26:34
you'll see some of the elements such as different headings, brand colors, and more, which we'll be able to copy and
2:26:41
put into our Tailwind CSS config. So let's do that next. Setting up a Tailwind CSS theme is
2:26:49
something that we have to do for every application independently because no matter how many of the applications
2:26:55
nowadays follow a specific boilerplate structure, still the designs of all of them have some differences. For example,
2:27:02
take a look at this Dev Overflow application that we have with this nice light and dark mode and then compare it
2:27:08
with a much brighter storage application. If anything, they have different fonts and different brand
2:27:14
colors. So, the main question is how to extract these values from these style guidelines to be able to use them within
2:27:21
the application. This is something we go into a lot of depth within our Ultimate NexJS course, but let me give you a feel
2:27:27
for that right here as well. First things first, you want to find a style guide or if you don't have it, you can
2:27:33
extract some colors right here from the application. There we go. You can see that this one uses
2:27:39
FA7275, but in this case, we thankfully have the style guide. So, we can go right here and we can copy this color.
2:27:45
Next, you can head over to Tailwind.config.ts. And by the way, I just use a command or controlP keyword,
2:27:53
which allows me to very quickly move to different files. I don't have to open it and then go there. I just press command
2:27:59
P, start typing, and I'm immediately within the file. That's just a little pro tip. So, how would you go ahead and
2:28:05
extend your theme to match your application's colors? Well, we can go theme, extend colors, and I'll add a new
2:28:13
object called brand. And I'll provide a default color for the brand. You can
2:28:18
provide a default by simply entering a default keyword. And you can paste the color that you just copied. And I'm also
2:28:25
going to provide a variation of that color which we can get by saying brand- and that's going to be #
2:28:34
EA6 365. After that, we can add all of these other colors as well. For example,
2:28:40
you can see this green one right here. Well, let's just copy it. Go back and then go below the brand and then say
2:28:46
green. And you can simply paste it right here. You get the idea, right? And how would you go ahead and add these colors
2:28:53
right here? Now, you will need to repeat this for other colors, and some might even be hiding within the design, such
2:28:59
as this one right here. Now, just so you don't have to manually search for all of these colors, in the description of this
2:29:05
video, you can find the complete Tailwind.config.ts file, where I took some time to extract all of these colors
2:29:11
from the Figma I provided. Now if you scroll down you'll be able to notice that there is one package which we don't
2:29:18
currently have which is Tailwind CSS animate which we'll use for some very simple spin animations on loading logos.
2:29:25
So let's go ahead and install it by opening our second terminal and running
2:29:32
mpmi-save-dev and we can paste tailwind CSS animate and press enter. Once you do that your application will be back to a
2:29:39
functional state. Now, let's head back over to our homepage and let's see if we can use this color. I'll type text dash
2:29:48
brand dash 100 or you can just say text-brand to get the default one and
2:29:54
immediately you can see that it works. Now sometimes you might use a series of different classes to position an element
2:30:01
properly like let's say something that you would always do display of flex
2:30:07
items center and justify dash center. You'll see this always and in this case
2:30:13
we have to add the age- screen for this div to take the full height of the screen. If you do that this will nicely
2:30:20
center the text. We can also change the background color to something like amber 100. And we can make this text bold by
2:30:27
saying font dashbold. And there we go. Now you can see this in the middle of the screen. But what would happen if
2:30:34
across many different components you had to position things in the middle of the screen. You would have to copy this
2:30:40
entire class name and then paste it across all the other pages. And if there's a change, maybe you want to give
2:30:46
it a border, you would have to make that change across all files. So to make sure that doesn't happen, we'll head over to
2:30:52
our globals.css where we currently have some predefined code given to us by the
2:30:58
next.js CLI. In this case, I'll remove it. We are importing the table utilities
2:31:05
and I'll give it an at layer utilities. And here we can define some
2:31:11
utility classes. What are utility classes? Well, they help us make our code more reusable. So if I head back
2:31:18
over to our div and copy all of these classes, I can now write something like this dot center at apply and I can paste
2:31:27
all of those classes right here. Then going back to page, check this out. I'll
2:31:32
just simply say class name center. If I do that, this page still works perfectly
2:31:38
and my code is looking much cleaner because now I'm not cluttering it with all of the other class names which have
2:31:44
to be reused. rather if I need to see what they're about, I can go into our globals. The combination of the Tailwind
2:31:51
CSS config and this globals.css file is what makes the styling so much more
2:31:56
seamless, especially when working in big applications. As you can see here, in a lot of cases, we'll simply have H1 bold
2:32:04
or H1 XL, and we need to be able to reuse those classes just like we reuse
2:32:09
the colors in the config. So in our case, going back to the style guide, we'll want to create a class for this
2:32:15
specific heading. We can click into it to see what it is, but we also already
2:32:20
have some information here. In any case, this is a heading one with a weight of
2:32:26
700 and it has this specific color. So in your utilities, you would do
2:32:31
something like this.h1 H1 add apply text-34 pixels leading -42 pixels and a
2:32:42
font-bold. And how do I know about those? Well, because I can see that right here. 34 pixels, leading 42, and
2:32:50
it is obviously bold. Now, you can create different variations. For example, an H5 would be 16 pixels of
2:32:57
text. It would have a leading of 24, and it would be semibold. Going back to our
2:33:03
application now, I can use it right here by simply saying h1. And it looks great.
2:33:10
Now that you know what kind of role the tailwind.config.ts and the globals.css files play into styling of our
2:33:17
application and considering the tailwind config is already done, we can now finish the globals in the GitHub readme
2:33:22
of this project. You can head over to the code snippets, find the globals.css, and paste it right here. As you'll
2:33:28
notice, we have a lot of these reusable classes that are going to make the styling of our application a bit easier.
2:33:34
I mean, how often do we have to use a primary button or how often do we have to center a div? Once you apply that
2:33:40
global, make sure that it is imported within the globals.css and immediately eslint will
2:33:46
let you know that we no longer have this center class name, which is great, but now we'll have some other ones like flex
2:33:53
dash center and hash-creen. And we're back at where we started, but now with a
2:33:59
completely finished style guide for our project. Next, let's focus on the first thing that a user sees when they visit
2:34:05
the application. It's not the dashboard, but the authentication. In this case,
2:34:11
it's going to be the login and registration screen. Before we go ahead and start
2:34:17
creating the authentication, we have to be really smart in how we're planning on architecting it. As a matter of fact,
2:34:24
you have to do that before starting to code anything. Nowadays, AI can also code UIs, but it's about how you
2:34:30
approach creating some of these pages that matters, how you architect them. So, in this case, let's try to compare
2:34:37
those two pages. We have the login and we have the registration. As you'll see
2:34:42
on the login, we have some different fields such as the email and the password. I don't think we'll need a
2:34:47
username there. But on the create account, we'll need all of these fields like the username, email, password,
2:34:54
confirm password, and more. So we have to figure out which things will be repeated and which things will change.
2:35:02
In this case, we know that the entire left side will be repeated as well as some of the parts on the right side such
2:35:10
as the buttons. So what does that mean for a NexJS application? How will we approach that? When it comes to creating
2:35:16
different layouts and the routing for those pages, Nex.js allows us to create
2:35:21
something known as group routes, which you can create by creating a new folder and wrapping its name within
2:35:27
parenthesis. Something like O. Within O, we can create two new
2:35:33
routes, which are going to be different folders that are going to have the name of sign-in as well as sign dash up. And
2:35:43
within those we can create new page.tsx files. Within each one of these run
2:35:49
rafce which will create a new react arrow function component. This one we
2:35:55
can call sign in. And we can repeat the same procedure within the other one by
2:36:01
creating a new page.tsx. Paste it and rename it to sign
2:36:07
up. Now, if you've done it correctly, you might want to go to O and then sign
2:36:13
in. But you'll quickly notice that this is a 404. That's because when you wrap a folder's name in parenthesis, it doesn't
2:36:20
create a route. It's just a route group, which means that it will not be counted when navigating through different URLs.
2:36:27
So, to get to the signin, you just have to say forward slash signin, and immediately you'll be redirected to the
2:36:33
sign-in page. But what creating route groups also allows us to do is to add a
2:36:38
new special file called layout.tsx that allows you to show some
2:36:44
shared UI or functionality across all of the pages within the route group. So
2:36:50
create a new rafce call it layout and since it's a layout it needs to have access to the
2:36:56
children. So I'll get children through props and then I'll define children as
2:37:01
react react node. Immediately within it we can render those children. But now we
2:37:07
can further style this div by giving it a class name equal to flex and
2:37:14
min-hreen. Within it we can create a section. So let's create it right here.
2:37:19
And within that section we can create another div that will contain the image which we can import from next image and
2:37:27
give it a source of dot do favicon. Iico. We can also give it an al
2:37:33
tag equal to logo and a width of about 16 a height of
2:37:40
16 and a class name equal to age- auto. You can see that prettier will
2:37:45
automatically restructure this for us. And I just remember that we don't even have to use the dot dot slash. We can
2:37:52
just start with forward slashfabicon. And below it, we can render a div that'll have a class name equal to
2:38:00
space-y and text-w inside of which we can render an
2:38:05
h1 with a class name equal to h1 that's going to say manage your files the best
2:38:13
way. Below it, we can have a p tag that'll have a class name equal to
2:38:19
body-1. And it can say something like this is a place where you can store all
2:38:26
your documents. And you'll want to give this section a class name of BG brand as
2:38:34
well as a padding of 10 to give it some breeding room. That's going to make it look like this. And I think you can
2:38:39
already start seeing where I'm going with this. The left side which is rendered within the layout will be
2:38:45
shared across both the signin and the signup. How do I know that? Well, we can
2:38:50
change the text within the page to say sign in. And we can change the text within the signup to say sign up. And
2:38:57
then you know that this is our layout. So now if we are on the sign in, you can see it right here on the right side. But
2:39:02
if I change the URL and go to the signup page, you can see that now it says sign up. So let's go ahead and finish the
2:39:08
layout so we can focus on the right side which means showcasing the forms of our application. But for the time being we
2:39:14
just want to get this nice looking logo as well as this greatl looking 3D illustration. To get it you can go to
2:39:21
Figma and then you can export this file right here. For example, you can export
2:39:26
this entire icon which contains the storage text by going to export and then
2:39:32
saying export logo. And you can do the same thing by exporting this illustration as well. Once you do that,
2:39:39
you can head over into your public and delete all of the current SVGs within the public folder and then drag and drop
2:39:46
the file that you just downloaded into your public folder. We can rename the logo to simply say logo. And we can
2:39:53
rename the second one to simply say illustration. And now we can use them
2:39:58
right here by replacing this favicon to simply say forward slash
2:40:04
logo.png. Let's give it a width of 224 and height of 82. And we can go below
2:40:11
this div containing the text and render another image that'll have a source
2:40:17
equal to for equal to
2:40:22
slustration.png. Let's give it an al tag equal to files, a width of
2:40:29
342 and a height of 342 as well alongside a class name of transition
2:40:37
dashall. What are we going to transition? Well, on hover, we want to rotate by
2:40:44
two. And on hover, we also want to scale it a bit to 105. So if we save this and
2:40:51
go back, you can see this nice looking illustration. And if you hover over it, it rotates and scales a bit. So it looks
2:40:59
great. But as you can see, this illustration looks a bit low res to me. So what you can do is you can get it
2:41:04
with a higher resolution, like 3x or more. But just so you don't have to manually download each one of these
2:41:11
icons, and you can see there's going to be a lot, such as these files, ones, images, video, and so on. Not to mention
2:41:17
these ones on the sidebar as well as the upload icons, log out, these ones right
2:41:22
here for different views, and so much more. Just to make the process of downloading all of these a bit simpler,
2:41:27
I went ahead and downloaded them for you. So, the only thing you have to do is delete the current public
2:41:34
folder, download and unzip the new one from the repositories readme down below, and then drag and drop it right here in
2:41:41
the root of your application. It's going to contain all of the assets, icons, images, and more. In this case,
2:41:49
we'll just have to rename the two files that we used because here we're using a bit of a clear name. So, the logo is
2:41:56
going to be under assets, icons, logo-fool. SVG. SVGs are much higher
2:42:03
quality than PGs. And for the illustration, we can get it by going to assets, images, files.png.
2:42:12
Now if you go back, this is looking much crisper. Let's play with the UI a bit by
2:42:17
giving this section a class name of hidden walf. So it's going to take 50%
2:42:25
of the screen items center justify- center on large devices flex. So what
2:42:33
does this mean? It means that typically it'll be hidden, but once we reach larger devices or higher, we want to
2:42:39
show it. And on extra-L large devices, we wanted to take two-fifths of the
2:42:44
screen instead of 1/2. Also, notice how ESLint saved me right here, saying that
2:42:50
just the center doesn't exist. This is going to be just the fi center. Let's also give this div a class name of flex
2:42:59
max-h00 pixels max-w of 430 pixels. Flex- call so the elements
2:43:07
appear one below another. justify- center and
2:43:13
space-y-12 for some extra spacing on top and bottom. There we go. Now the left side is looking much better. But what
2:43:20
about the right side? Well, let's create another section right below this
2:43:26
section. And this section will have a class name equal to flex flex- one flex-
2:43:35
call. So the elements appear one below another. Items dash center. This one
2:43:40
will have a bg white because it's on the other side. Padding of four and padding
2:43:46
y of 10 for top and bottom. On large devices justify center. On large devices
2:43:52
padding of 10. And on large devices padding y of zero. Within it. We want to
2:43:59
display a div. And that div will have a class name of margin bottom of 16. And
2:44:06
on large devices hidden within it, we want to display an image. And this image will have a source
2:44:13
equal to
2:44:22
for/assets/icons/logo-fool-and.svg with an al tag of logo, a width of 224, and a height of 82.
2:44:31
with a class name equal to age- auto
2:44:37
W-200 pixels and on large devices W of 250 pixels. Finally, we want to put this
2:44:44
children within this second section right below this div containing the image. If we do that, you can notice
2:44:51
that we have nicely centered the signup page as well as the content on the left.
2:44:56
Now, if we head over to the sign-in page, you can notice that it doesn't look as good, even though it's using the
2:45:02
same layout. Let's check it out. Right here, we have the sign-in page and the signup page and the layout right in the
2:45:09
O. What I'll go ahead and do is reload the terminal by pressing Ctrl C to stop
2:45:14
it and then rerun mpm rundev. Now, I'll reload the page and you can see the
2:45:19
changes took effect. Sometimes you might need to reload your application if something seems weird because we have
2:45:25
done everything correctly. We have modified the layout which should result in changing all of the files or all of
2:45:31
the pages within the O route group. So now we ready to focus on the right side
2:45:37
implementing the O form. To get started creating our O
2:45:42
form, let's head over to our file explorer and create a new folder outside of the app folder. and I'll call it
2:45:50
components. Within components, we can create a new file called
2:45:55
o form.tsx. Run rafce. And now we can import it within
2:46:02
the sign-in page. We can do that by simply immediately returning it here by
2:46:07
saying o form coming from components o form which is going to be a self-closing
2:46:13
component. And to make it reusable, we'll pass it a single prop called type
2:46:19
is equal to sign in like this. Now we can do the same exact thing on the
2:46:25
signup. So let's copy this and move it over to sign up. If you don't have opening and
2:46:32
closing brace, then that means that we're having an immediate return. So we're immediately returning just the o
2:46:39
form. And that's the only thing we have to return from both of these pages. Now,
2:46:44
right now, as you can see, the odd form is complaining because we're not accepting the proper type. So, let's
2:46:51
head over into the o form and let's start implementing it. First things first, I'll accept and dstructure the
2:46:57
type, which is going to be type of a type. And we can declare it right here
2:47:02
above by saying type form type is equal to either sign
2:47:11
in or sign up. And now we can just say that this type will be of a type form
2:47:20
type. Perfect. And now we are ready to start implementing a form which we'll reuse for both of these pages. To
2:47:27
implement it, we'll use Shatzen, a beautifully designed component library that allows you to copy and paste code
2:47:34
into your apps. Specifically, we'll search for form. And it says right here
2:47:39
that we'll be using React hook form and ZOD because forms are tricky. They're
2:47:46
one of the most common things you'll build in a web application, but also one of the most complex. So in this case
2:47:52
they'll use the form component in a wrapper around the react hook form library which is going to just make it
2:47:59
so much easier for us to develop the forms. Here they go a bit over the anatomy give an example but what we are
2:48:06
interested in is the installation process. So let's go ahead and follow this together. I'll put this side by
2:48:13
side to my code editor right next to my IDE. And now I can zoom it out a bit and
2:48:19
we can follow the installation process. First things first, we have to install SHAT CN because this right here is just
2:48:26
making sure to add this Shaten component into it. But if I head back to
2:48:31
ui.shhatn.com and click get started, head over to installation for
2:48:36
Nex.js, you can see that we need to run mpxhatn at latest in it. So let's copy
2:48:43
this command and paste it right here. Once you do that, it's going to ask us
2:48:48
whether you want to install the installer. And after that, it's going to ask you a couple of questions. Which style would you like to use? In this
2:48:56
case, I'll proceed with New York. We're going to use a neutral color. And we don't need to use CSS variables. So, in
2:49:03
this case, I can switch over to no. Now, it says it looks like you're using React 19 and some packages may fail to install
2:49:11
due to peer dependency issues. It's asking us whether we want to use force
2:49:16
or use legacy pure depths. In this case, I'll just press enter to use
2:49:21
force and it's going to install them. We can see what this exactly did. If we
2:49:27
head over to the package JSON and check the versions of dependencies, these have remained the same, React 19. And I think
2:49:34
it's just going to work. So, let's head back to the installation of the actual form and let's copy this command that
2:49:40
will allow us to add the form to our application. And once again, it's asking
2:49:45
us how we would like to proceed. I'm going to say use force. And it's going to add a form
2:49:52
button and a label. Now, how shatzen works is completely different to all of
2:49:57
the other libraries such as material UI or Bootstrap where by installing it, you get all of the components immediately
2:50:04
within your code. But by using SHAT CN, a new UI folder gets created and you can
2:50:10
only use the components that you manually decide to install and use. In this case, we're using a form component.
2:50:16
So, it brought all of this code to you. So you can actually modify it if you want to, but you won't really need to
2:50:22
because we're just going to use what they provide to us and then style it further by using tailwind and CSS. So
2:50:28
now that we have installed it, we can continue with some of the additional setup. Next, we have to define the
2:50:34
schema of your application. So let's copy the next code block right here and
2:50:40
paste it at the top here. We make it a use client because this is a form after
2:50:45
all. And we define the form schema. After that, we have to copy the Zod resolvers and use form as another pair
2:50:52
of imports. And then we have to define this profile form. In this case, I'll
2:50:58
just copy what goes inside of the form and paste it within our O form. That's
2:51:03
going to be the form definition as well as the onsubmit function. After that, we need to get
2:51:08
more imports. So, these are going to be imports for inputs, forms, and buttons.
2:51:14
And I'm going to put them right here at the top. And we then have to get the actual UI of the form. So I'll copy it
2:51:22
and I'll paste it right here under the return. If I do that and save it, ESLint
2:51:28
will automatically position everything. And I'll take a second to explain how all of this
2:51:33
works. First of all, it looks like the input hasn't been installed by SHA CN.
2:51:39
So we can easily install it by saying MPX shad CN at latest add input. After
2:51:46
that we can see that it got installed and we have our form schema which right now contains only the username. Then we
2:51:53
define our form by using the use form coming from react hook form library and we say that it'll be of a type form
2:52:00
schema meaning that we'll use the username and we also set the default values. Finally we define a submit
2:52:06
handler which we can use the arrow function to do so. It's going to be an asynchronous arrow function that accepts
2:52:14
the values and then for now simply console logs them. Finally, right below we return the form with a single form
2:52:20
field. So if we go back to our application specifically to the sign-in page, you should be able to see a
2:52:26
beautiful looking input. Of course, if you go to desktop devices, you'll be able to see that it looks even better.
2:52:32
But on mobile, we remove this left side because we don't have any space and just show store it on top. Now, let's modify
2:52:38
this form field to make sense in our case to turn this into an odd form. First things first, I'll wrap this form
2:52:45
into an empty React fragment, and I'll close it with it as well, because later on, we'll have our OTP verification
2:52:52
happening right here. For the time being, I can simply comment it out, but later on, we'll add it back in, which is
2:52:59
why we need to turn this into a React fragment. Now we have this form here and let's give it a class name equal to
2:53:06
O-form. This will give it a full width. Right within the form we can create an H1 and this H1 will check if the type is
2:53:15
sign up. So we can say type is sign in then it'll say sign in else it'll say
2:53:20
sign up. We can also give it a class name equal to form-ashtitle. Now let's
2:53:27
go below and we have a form field. This form field will only show if we're on
2:53:33
the sign up. So we can say if type is triple equal to
2:53:39
sign-up in that case render this form field. And of course we'll have to properly close it right here if that is
2:53:46
not the case. So since we're on the signin, we don't have any fields right now. But if I head over to sign up, you
2:53:53
can see that we still don't have anything. Why is that? Well, let's head over to the sign up page. And it looks
2:54:00
like I forgot to change the type. So, this perfectly illustrates how we can use props to modify how a reusable
2:54:07
component should look like. Now, what will this first form field be about? It'll be a full name field where we
2:54:14
return a form item. And within a form item, we have a div element with a class
2:54:21
name equal to shad form item within which we display a form
2:54:27
label. And that form label will simply say full name. Next, right below it, we
2:54:34
have a form control with the input. In this case, we don't have a description. So, it'll look something like this. Form
2:54:40
label and form control with the input within the div. And then form message right below.
2:54:46
Let's style this label a bit by giving it a class name equal to
2:54:51
shad-form- label. And let's go into the input and give it a placeholder equal to
2:54:58
enter your full name. And we can give it a class name equal to
2:55:04
shadinput. Finally, we can give this form message a class name equal to
2:55:10
shad-form message. That happens if there is some kind of an error. We can nicely
2:55:15
show it below. Now let's duplicate this form field by copying it and let's paste
2:55:20
it below this check for the signup. The second one will be displayed either way. So we can change it to email. Next we
2:55:28
can change the label to email as well. We can change the placeholder of the input to say enter your email. And
2:55:36
that's it. The rest will be the same. Since we'll use OTP verification, we don't even need a password field. OTP
2:55:43
verifications are more secure. You'll see how that works very soon. Now, below this form item, we can render a button
2:55:50
with a type of submit. It'll also have a class name equal to
2:55:55
form-submit-button. And within it, we'll check if type is equal to sign in, then it'll say sign in. Else it'll say sign
2:56:03
up. And there we go. We have our beautiful button. We can also have some kind of a loading state. So I'll go up
2:56:10
and I'll create a new use state field right at the top of the component by
2:56:15
using the use state snippet. I'll call it is loading set is
2:56:22
loading at the start set to false. And I like how my webtorm immediately tells me
2:56:27
that this false actually stands for the initial state. Now if I go down below this text still inside the button if is
2:56:36
loading is true then I'll render an X.js image that'll have a source of
2:56:43
forward/assets/icons/loadader.svg SVG an al tag of loader a width of 24 a
2:56:53
height of 24 and a class name of margin left of two to divide it from the text
2:56:59
and animate dash spin. So if I simulate loading by turning this default variable
2:57:04
to true, you should be able to see how that looks like. There we go. Sign up. And at the same time, we can also
2:57:11
disable that button because we cannot click it again if it's loading. So we
2:57:16
can give it a disabled property and it'll be disabled if is loading is true.
2:57:21
Now let's go below the button and there I'll check if we have an error message.
2:57:27
So if error message is true then I'll render a p tag that'll render an
2:57:33
asterisk and then error message and we can give it a class name equal to error-
2:57:39
message. Of course, this error message is a new state which we have to create which we'll use to track the state. So
2:57:47
I'll use a new use state snippet to quickly spin it up. I'll call it error
2:57:53
message and set error message and the start equal to an empty string. Now if
2:57:58
we go down, we can go below this error message and we can render a div. This
2:58:04
div will have a class name equal to body-to flex and justify- center. Within
2:58:12
it, I'll render a p tag that'll check if type is sign in. Then it's going to say
2:58:18
don't have an account. Else it'll say already have an account like this. Of course, we have to give it a
2:58:25
class name of text- light- to make it a bit muted. And then
2:58:31
below this B tag, I'll render a link component coming from next link, I'll give it an href. And if the type is
2:58:38
triple equal to sign in, then it'll point to sign up. Else it'll point to
2:58:44
sign in. So basically the other one. I'll also give it a class name equal to margin left of one font- medium and
2:58:52
text- brand. The link can say if type is sign in then sign up else sign in. But
2:59:00
it looks like I imported the wrong link component. This link should actually be a default import and it should be coming
2:59:06
from next forward slashlink. There we go. So now we can see the text and check this out. If you
2:59:13
click it, we can now move between those two different pages. This is looking
2:59:18
great. I'll remove the form description since we don't use it. And let's head back down. Looks like this animate spin.
2:59:24
I misspelled it. Nice how ESLint caught that for me. That was supposed to be animate spin and we can continue right
2:59:32
below. Now that we have implemented the UI of the form, we have to look into making it functional because right now
2:59:39
you can see that our names have some kind of errors saying that email is not
2:59:44
assignable to type username and that's because all of this is so neatly hooked up to our use form the default values
2:59:52
and the form schema. So let's actually modify it to reflect our use case. Right
2:59:57
here at the top I'll say const O form schema is equal to and then given the
3:00:04
form type of this form which is going to be of a type form type I can return
3:00:11
different things. So I'll return a Z.Object which stands for zod that'll
3:00:17
have an email field and we'll have the email field always. So that's going to be Z.string string and email. But we can
3:00:25
also sometimes add a full name and the full name will only be there if the form
3:00:31
type is triple equal to sign up. In that case, we can have a
3:00:37
Z.string min.max 50 else Z.null. So what this
3:00:43
means is that this o form schema will be different given the type of form we're on. So let's actually pass it right here
3:00:51
by saying const form schema is equal to o form schema which we call and then
3:00:57
pass the correct type to it. We also need to modify the default values. So for default values I'll say full name is
3:01:04
an empty string and I'll also say email is an empty string as well. And we can
3:01:10
delete the previous form schema. And now we can see what error do we have here. It seems like there's an error with this
3:01:16
input saying it's not assignable to null. Yep. So in this case, instead of using the null, we'll use the dot string
3:01:24
and then dot optional on it. There we go. That makes
3:01:29
more sense. And now our input isn't complaining. So now if you click sign up, you can see that it gives you a
3:01:34
required field and an error for both of these. That is exactly what we wanted.
3:01:40
Same thing for detailed validation. string must contain at least two characters or this has to be a valid
3:01:46
email. I mean implementing this validation is just super easy using zod
3:01:51
validation. Now what error do we have here? A component is changing an uncontrolled input to be controlled.
3:01:57
This is definitely something we can look into but I don't think it's even happening anymore. So I think we're good. And as I said we can now switch
3:02:05
between both of these forms. Now the question is are we getting those values right here once we submit? Let's give it
3:02:11
a shot. If I go to inspect element and I open up the console and I clear it, I'll
3:02:18
try to enter my name Adrian and my email and I'll click sign up and take a look.
3:02:25
We get an email and the full name right here in the object. And that means that we are ready to sign the user up or in
3:02:32
this case actually create a user in the database. And of course, I don't even have to mention that this application
3:02:38
looks so much better on desktop devices. This is great. So, with that in mind,
3:02:44
let's go ahead and implement our backend system next. So, we can actually create user accounts, store those users in the
3:02:50
database, and allow them to attach their files to their store management
3:02:56
solution. To develop our backend, we'll use AppRight. It allows you to build
3:03:02
entire backends within minutes and scale effortlessly using their open source platform. Of course, even though it says
3:03:08
you can do it within minutes, don't be fooled. This is not some kind of a plug-andplay no code backend system.
3:03:15
Rather, you have complete control over your O databases, functions, storage, and more. For this project, we'll use
3:03:22
the database functionalities, authentication to authenticate our users, and finally storage to keep track
3:03:28
of our files. Now, I like using Apprite because it is simple to set up and most importantly, if you take a look at their
3:03:34
pricing, you'll notice that with the free plan, you get unlimited projects which are never paused. And this is what
3:03:40
is super important. Some other tools allow you to use their software for a specific period of time, but then they
3:03:46
pause your projects. Here, you can have unlimited that are never paused, and you get more than enough bandwidth, storage,
3:03:52
executions, and everything else to be able to run your project. If your project doesn't get tens or even
3:03:58
hundreds of thousands of users, you'll most likely never have to upgrade to a pro tier. But even if you do, I've got
3:04:04
you covered. By clicking the link down in the description, you'll be getting 50 bucks worth of free credits if you do
3:04:11
decide to upgrade. So, with that said, click the link down in the description to be able to follow along and see
3:04:16
exactly what I'm seeing and then sign in with GitHub. Once you do that, you can create a new organization or just choose
3:04:22
personal projects and apply credits if you need to. And you'll be able to apply the credits if you actually do decide to
3:04:28
upgrade. In this case, I'll just head over to my dashboard and create a new project. Call it JSMore and then give it
3:04:36
a name. I'll use store it. You'll have to do something else. Click next. I'll
3:04:41
choose Frankfurt as it's closest to me. And there we go. Our project has been created. Oh, this is pretty cool. The
3:04:47
weekly database backups are now available. I'll choose a platform in this case web. And we'll have to enter
3:04:54
the name of the web app. So I'll just say store it web. And for the host name, I'll just
3:05:00
put asterisk. So everything works for now. Next, appite is going to guide us through the installation process. For
3:05:06
now, you can skip these optional steps as we're going to do everything together. Let's start by copying our
3:05:11
environment variables. I'll put my browser side by side by the editor and I'll create a new enenv.local file
3:05:19
within which we can store our environment variables. First things first, let's create a
3:05:27
next_pub_apprite project and make that equal to this ID that we just copied.
3:05:32
Right below it, let's head over to databases and then let's create a new database. I'll give it a name of general
3:05:40
and create. We can also copy this ID right here by giving it a
3:05:47
next_public_apprite database and set it equal to the ID that we just copied. Within this database, we can create two
3:05:54
different collections. Let's create a first one which is going to be called users. And let's copy its ID as well. We
3:06:01
can add it to our env by saying next_pub_appite
3:06:08
users_colction is equal to this ID here. And while we're here, let's immediately add some attributes that each one of our
3:06:15
users will have. Head over to the attributes tab and click create attribute. Let's start with a string.
3:06:21
And let me actually expand the browser and give it a key of full name size of
3:06:27
255. No need for the default. and let's make it required. Let's create another
3:06:33
one. This time of a type email. It's going to be called email and it'll also
3:06:38
be required. After that, we can create a new avatar which is going to be of a type string. And we don't have to enter
3:06:44
the size and we don't have to make it required. I'll just click create. Oh, but that says that we have to add it.
3:06:51
So, I'll choose the maximum number for the size. Remove the comma from here and click create. Finally, let's add another
3:06:57
string of account ID of a size 255 and make it required and click create. After
3:07:05
that, go to settings, head over to permissions, click any and make sure
3:07:10
that all boxes are checked. This is going to give us the right permissions to be able to update the users in this
3:07:16
collection. Now, we can repeat this for another collection. So, let's go back to our database and create a second
3:07:22
collection, which is going to be called files. Once you create it, you can copy its ID and duplicate this one right here
3:07:29
and rename it to next public files collection and paste the new ID. Once
3:07:35
you do that, we can also add some attributes such as a name. Each file can
3:07:41
have its own name. Let's enter a size of 255 and make it
3:07:47
required. After that, we have to give it a URL and the URL will be of a type URL.
3:07:53
So let's call it URL and make it required as well. Next, we can choose a
3:07:59
type of the file which is going to be of a type enum. So let's search for
3:08:05
enum. Let's call it type and different elements that it can have are going to
3:08:10
be document image and just to create new ones just press space or add a comma
3:08:17
video and audio and other make it required and click create. After that,
3:08:23
let's add a bucket field. So, this is where we're going to be storing that file. Let's choose 255 and make it
3:08:30
required. After that, let's add another one which is going to be a string of account ID of 255 and it'll be
3:08:38
required. After that, let's create a relationship. So, that's the last thing right here. It's going to be a two-way
3:08:45
relationship related to the collection of users. And the relation will be many to one which means that files can only
3:08:52
contain one user while users can belong to many files. The attribute key right here doesn't have to be users it can be
3:08:58
owner. So who owns the file and on deleting document set it to null and
3:09:03
click create. Finally we can also keep track of the file extension. So let's say
3:09:09
extension of size 255. Don't have to make it required.
3:09:14
Finally, we can keep track of an integer which is going to be the size of the file. We don't have to make it required.
3:09:20
And finally, we can share that file with some people. So, let's create a new string called
3:09:27
users. And here we'll actually create an array of users. So, click create. And you can choose any kind of size. I'll
3:09:33
enter the same max value that we have right here. And click create. And I
3:09:39
believe that's it. We just have to go to settings, head over to permissions, and
3:09:44
choose any and tick all the boxes. That way, we won't have any problems with permissions. And finally, we have to
3:09:52
head over to storage, which is the last icon right here, and create a new bucket. Let's call it file storage.
3:10:00
Click create. And you'll get the ID of that bucket. Once you get it, let's collapse it. And let's create a new
3:10:12
next_public_appite_bucket is equal to this ID right here. Great. And believe it or not, that's it when it comes to
3:10:18
the app right setup. Now we can focus on integrating apprite within our code to then store our users data and files. So
3:10:26
let's do that by installing a node app package. This one right here. It'll initialize your SDK with the apprite
3:10:33
server API endpoint and project ID that we just created. So you can very quickly perform any kind of actions or requests
3:10:41
through SDK calls. I'll show you how that works. But first we have to install it. So let's go open up the terminal and
3:10:49
run mpm install node-apprite-save. And this is a common
3:10:54
problem since we're using the latest versions of Nex.js. To fix it, head over to package.json. JSON and check our
3:11:02
versions. We're using the latest versions of Nex.js, but React is under RC versions,
3:11:08
but it's still possible that some other packages might not yet work with the latest versions of React. So to fix
3:11:14
that, we have to add a new object called overrides. And in overrides, we can
3:11:20
specify that all packages have to use a version of React that is defined in the
3:11:26
dependencies. And we can do that by saying dollar sign react. And we can
3:11:32
repeat the same thing for react. If you do that, let's try running the same command one more time. mpm install node-
3:11:40
apprite. And as you can see now, it worked like a charm. Now, just so we don't have to recall these environment
3:11:46
variables every time by their name, what we can do is create a new file in the
3:11:51
lib folder or rather a new folder called apprite. And within it we can create a
3:11:57
new file called config.ts. And inside of this file we
3:12:04
can import all the enviately for easier access. We can do
3:12:09
that by saying export const appite config is equal to and now here we can
3:12:16
pass over all the links. Endpoint URL is equal to process.env.next
3:12:25
next underscore public underscore apprite underscore
3:12:30
endpoint and we can add an exclamation mark at the end so typcript knows that we know that the variable exists there.
3:12:37
So let's actually make sure that it is indeed there. We can go over to env local and it looks like we're missing
3:12:44
the endpoint. So let's add it by saying
3:12:50
next_public_appite endpoint which is going to be equal to https col/
3:12:59
slashcloud.apprite.io slashv1. Now let's repeat the process for all of the other variables such as
3:13:06
project ID is process.env.next Next public apprite
3:13:15
project. Next we have a database ID equal to
3:13:21
process.env next public apprite database. And now that I look at it, the
3:13:28
easier way to approach this would be just to copy all of the names. So let's copy them, paste them here, and divide
3:13:34
them by commas. And then add the proper names right here at the left side. So it
3:13:40
can be something like users collection ID is going to correspond to the
3:13:46
outright users collection. Next we have the files collection ID which is going
3:13:52
to correspond to files. And last we have a bucket ID which is going to correspond
3:13:58
to the apprite bucket. We can also add exclamation marks at the end. So we tell
3:14:03
Typescript that we know that the variable is indeed here because we know that it is coming from
3:14:09
process.env. Right below it we can also add the final variable called secret key
3:14:15
which is going to be equal to process.env next
3:14:21
apprite_key exclamation mark. As you can see we don't have the keyword public in front of it because this will not be
3:14:27
publicly available on the front end only on the backend server actions. Great. With that said, we now have this file
3:14:34
which we can use to initialize the AppRight Node SDK. Now, scroll down and
3:14:40
head over to integrations and click API keys. Create a new API key and let's
3:14:46
give it a name, store it. And I'll set the expiration date to never. Once you do that, you can select all scopes and
3:14:52
click create. As soon as you do that, you'll get your secret key. So, copy it and let's add it right here to our
3:14:59
environment variables. as next underscore
3:15:06
apprite secret and make it equal to the key that you just copied. Now we are
3:15:11
finally ready to start setting up our app right config. Within the app right folder in the lip folder, create a new
3:15:17
file called index.ts. This is where we can put our setup. In our case, we'll be using node
3:15:24
app SDK so we can make sure that all of our services work on the server side. To
3:15:30
use node apprite we first have to create an apprite client. So let's do it by
3:15:35
saying export const create session
3:15:40
client is equal to an async function inside of which we can declare
3:15:46
our client and set it equal to new client which we can import from node
3:15:52
apprite and then on it we can call a set endpoint which we can set to appreite
3:15:58
config coming from config.ts ts dot endpoint URL and we can call a dot set
3:16:07
project which we can set to operate config dot project id. This client will
3:16:14
be used to initialize instances and services like databases and accounts
3:16:19
ensuring that they stay connected to the same apprite project. There are two possible ways to create a client. create
3:16:26
an admin client and create a session client. In this case, we're creating a session client as you can see by the
3:16:32
name of this function. This client will be linked to a specific user session letting users access their data and
3:16:39
perform actions they're allowed to such as when logged in users can manage their own data like view or update their
3:16:45
profile. On the other hand, the second function export const create admin
3:16:51
client which is equal to an async function. This one, on the other hand, is much more powerful. This one creates
3:16:59
a client instance with admin level permissions to manage your entire AppRite project. We're going to only use
3:17:06
it on the server when we need to do things like create users, manage databases, or handle tasks that need a
3:17:12
higher level of access. This should never be exposed to the users directly. And you might be asking, why are we
3:17:18
going to create a new client for each request? Well, the reason is because sharing the same connection between
3:17:24
requests can lead to security issues like exposing someone else's data or session. So, always create a new client
3:17:31
connection for each request to keep data safe and secure. Now, let's continue setting up our session client by
3:17:40
creating a new session variable equal to. In this case, I will await
3:17:47
cookies coming from next headers. And then outside of that, I'll call a get
3:17:53
apprite dash session. Next, we can check if no session. So, if the session
3:17:59
doesn't exist or if there is no session value, we want to simply throw a new
3:18:06
error that's going to say no session. If there is a session, we will say client
3:18:12
set session and we'll set it as session do value. Finally, we want to return two
3:18:19
different getters. Return get account which will simply return a new account
3:18:28
coming from apprite to which we pass the client. And we can create one to get
3:18:35
databases which will return new databases which we have to import from
3:18:41
apprite. So get databases. As you can see all of these are coming from node
3:18:47
apprite. Make sure to add a comma right here. And this is our create session
3:18:52
client. Now we can do a very similar thing for our admin client. So what I'll do is I'll copy the entire code within
3:18:59
create session client and I'll paste it within create admin client. I'll keep
3:19:05
everything the same but I'll remove everything that has something to do with the session. And after we set the
3:19:12
endpoint and set the project, we want to set the key that will allow us to perform admin actions which we have
3:19:18
under apprite config secret key. Finally we return get account get databases but
3:19:25
in this case we can also get storage and within it we can return a new storage to
3:19:31
which we can pass the client and finally we can also do get avatars where we can
3:19:36
return new avatars and also pass the client. Make sure to import the avatars
3:19:42
coming from node apprite and same thing for storage. Make sure to import it from
3:19:47
node apprite. There we go. Now we're looking good. We have functions that allow us to create admin clients and
3:19:56
session clients that will then allow us to use all of these functionalities which we're exposing right here. Account
3:20:02
and databases for the session client as well as everything else for the admin client. So with that in mind, let's
3:20:09
create our first server action that will allow us to sign our users up. I'll head
3:20:15
over to lib and create a new folder called actions. And within it, I'll
3:20:20
create a new file called user.actions.ts. And here we'll focus on
3:20:27
the create account flow. That flow will look something like this. So I'll just
3:20:32
put it here as a comment just so we know what we're working on. We first want to make sure that our user enters their
3:20:39
full name and email. Then we need to check if the user already exists using
3:20:44
the email which we will use to identify whether we need to create a new user document or not. After that we send the
3:20:51
OTP which is a one-time password to the user's email. Step four is to have a
3:20:56
secret key for creating a session. Step five is to create a new user document if the user is a new user. Step six is to
3:21:04
return the user's account ID and finally verify the OTP to authenticate the
3:21:09
login. So let's create a new server action called const create
3:21:17
account is equal to an async function that will accept a full name and email
3:21:23
which we will dstructure of a type full name string and email of a type string and we
3:21:32
can open up a function block that's going to look something like this. Now I
3:21:37
just remember that we have to call this on the server side which means that we have to give this function a use server
3:21:45
directive just like this to make sure that this code never gets run on the client because otherwise we might expose
3:21:52
our secret key. In the same way another file that should never be exposed is our index.ts within the lib folder here. We
3:22:01
also have to make this a use server only file. So good thing that I remember to
3:22:06
do that. Now let's create this create account function or server action should
3:22:11
I say. First things first we want to get access to the potentially existing user
3:22:17
by saying constex existing user is equal to await get user by email to which we
3:22:26
pass our email. Now this get user by email function is something that I will teach
3:22:32
you how to create. It'll be a helper function which we can create just above the create account const get user by
3:22:41
email which accepts one parameter of email of a type string and let's turn it
3:22:47
into a functional component and within it we can get access to the
3:22:52
databases by saying equal await create admin client. Okay, so we want to get
3:22:59
access to the admin client permissions over the database and we have to make it async because we're using a weight here.
3:23:05
Below it, we'll say const result is equal to a weight
3:23:11
databases.list documents. And specifically, we need to tell it which documents we want to get. So we'll get
3:23:17
the documents from the database with the id of appert config database ID and from
3:23:24
the user collection which we can get by saying apparate config user collection ID and we have to write a query which is
3:23:31
something like query coming from
3:23:37
apprite equal email is the email we're searching for and I think we need to put
3:23:43
it within an array. Once we do that, if we have the result, we can then say if
3:23:48
result dot total is greater than zero, then we can
3:23:54
return the result. documents zero. Else we can return null because we cannot
3:24:00
find a user. And now within create account, we have this nice helper function allowing us to fetch the
3:24:06
existing user. Now if we have an existing user we can then get its account ID by saying const account id is
3:24:13
equal to await send email OTP to this specific
3:24:21
email. Once again, this is another function that we have to create const
3:24:27
send email OTP onetime password which is an async function that accepts an
3:24:34
email and that's going to be an email of a type string. And here we can once again get access to the account
3:24:40
functionalities by calling it from the create admin client. We can open up a
3:24:46
try and catch block that's going to look something like this.
3:24:51
In the catch we get the error and in the try we can try to get
3:24:56
access to the session by saying con session is equal to await account
3:25:03
dotcreate email token to it we can pass a unique user ID by saying id dot unique
3:25:11
and this is coming from apprite and the second parameter is the email we want to connect it with that's going to give us
3:25:17
access to the session so we can return the session dot user
3:25:22
id and in the catch we can simply handle that error. So instead of simply console
3:25:28
logging it I'll actually create another helper function con handle error where
3:25:35
we have access to the error of a type unknown and we have a second parameter of message of a type
3:25:41
string and here we can simply console.log log the error and the
3:25:47
message and I can simply throw that error. So now we can call this handle
3:25:54
error function and simply pass the error to it and then some kind of a meaningful
3:26:00
message like failed to send email OTP and don't forget to import this ID
3:26:05
coming from apprite specifically node apprite. So let's get it right here.
3:26:12
query and ID coming from node apprite. And I think I can remove this comment
3:26:17
right now because you know what we're doing. I'll repeat it one more time. We're trying to get the user by
3:26:23
email. Then we will send it a new OTP verification to make sure that the user
3:26:29
who entered that email is actually the user under that email. After that, we will get its account ID and we'll make a
3:26:37
check. If there is no account ID, we're going to simply throw a new error.
3:26:43
Failed to send an OTP. And finally, we have to have a case where there is no
3:26:48
existing user. We can get access to the databases functionality because we'll have to create a new document in the
3:26:56
database. So we can say await databases.create
3:27:02
document. First we have to say where in which database we want to create it. So that's appreconfig ID. Then we have to
3:27:11
say to which collection we want to add it to. That's going to be the user collection ID. Then we have to give the
3:27:18
ID of this new document we want to create. That's ID unique. And then we have to pass the actual data which is
3:27:24
going to be the full name. It'll be email. It'll contain an avatar which is
3:27:31
going to be just a random placeholder avatar logo. So if you search for avatar
3:27:37
image, we can find a random placeholder one. Yeah, I think something like this will be good. So I will simply copy its
3:27:44
image address and I'll paste it right here as a string. And finally, after
3:27:50
avatar, we want to make sure to give this user an account ID. Finally, we can
3:27:55
go below this create document and below this if where we're checking for the existing user and we
3:28:02
can return parse stringify and then to it we can pass an
3:28:09
object containing the account ID of this new user. But what even is this parse
3:28:15
stringify? Well, this is going to be a simple utility function which we can create in the utils file. It's going to
3:28:22
look something like this. Export const parse stringify which is going to accept a
3:28:29
value of an object. For now, I'll set it to unknown. And it's going to return
3:28:37
JSON.parse of JSON.stringify of that value. Whenever
3:28:43
passing large payloads through server actions, we first have to stringify and then parse that value. So that's the
3:28:49
reason why we're doing this. And we'll be doing that many times. So instead of simply saying JSON parse JSON stringify
3:28:55
every time, we can use this function parse stringify which we can now import
3:29:01
from utils. Great. And that is our create account server action. Oh, I just
3:29:08
noticed one thing. I misspelled existing. You can see even webtorm is
3:29:13
pointing this to me. Typo in word existing. And now it's giving me a couple of options to rename it to
3:29:19
existing. There we go. That's much better. Now let's export this create account function so we can use it within
3:29:27
our form. I'll head over to o form.tsx. And remember where we left off
3:29:34
right here under the onsubmit. So here once we start submitting we want to set
3:29:39
is loading to be true because we're doing some action. And then we want to try to create a new
3:29:46
user by saying const user is equal to create account which is now coming from
3:29:53
our server actions and to it we have to pass the full name and email. Full name
3:29:59
will be equal to values.f fullname and email will be equal to values.mmail. If
3:30:05
we don't have a full name we can just set it as an empty string which is going to be the case when we're trying to log
3:30:11
in. So we can set it as empty string right here. Now let's create a new use
3:30:16
state snippet. And I'll call it account ID and
3:30:21
set account ID at the start equal to null. And right where we have the user, we can call set account ID and set it to
3:30:30
user.ac account ID. But we only want to perform this if we're on the sign up
3:30:37
functionality. So let's actually open up a new try and catch block. And in the try, I'll call this
3:30:44
functionality that I just added. And in the catch, I'll simply set an error
3:30:51
message to something like failed to create an account. Please try again. And
3:30:57
we can also have a finally in which case we're going to simply stop the loading no matter what
3:31:04
happened. So we can say set is loading to false and as soon as we start
3:31:09
submitting we can reset the error messages. So the error message is an
3:31:15
empty string. Now in this case it looks like it's saying that user account ID
3:31:20
does not exist on type promise which means that we have to await the functionality of create account. So
3:31:28
let's add the await keyword right here and this should be enough for us to test the process of creating an account. So,
3:31:35
let me enter my name right here and let me enter my email and I'll click sign up. There we go. We saw a loading and
3:31:42
even though it appears like nothing happened, I believe the request has been sent. And would you look at that? Hello.
3:31:49
Enter the following verification code to securely sign in to JSM store account
3:31:56
330792. But now a better question is where the heck will we enter that password? We don't have an OTP modal.
3:32:04
This is the thing I'm talking about. So in the next lesson, let's focus on creating this modal so we can finally
3:32:10
perform a first action that would connect our UI, the front end, with the
3:32:16
server side, allowing us to create an account. To get started creating our OTP
3:32:23
modal, let's head over to components. And within it, let's create a new file
3:32:28
called OTPO.tsx. While you're in there, run rafce to
3:32:35
quickly spin up a new React functional component. And let's import it just so we can see it. But the better question
3:32:42
is where are we going to use this OTP modal? Well, it only has to be used on the sign up page. And specifically, the
3:32:49
signup page itself refers to the O form. So, we're going to put it right here at
3:32:55
the bottom of the O form. I think we have already left a comment for ourselves right here. specifically will
3:33:01
only do it if an account ID exists. So if account ID exists that means that the
3:33:06
user has tried to verify themselves and then we can show an OTP model. So let's
3:33:13
render it properly. OTP model coming from components modal and to it we can pass the email coming from
3:33:21
form.get values and I'll pass the email and finally the account ID is equal to
3:33:28
account ID. We'll use these props within the OTP model to make sure to verify our user properly. So now we don't have any
3:33:37
kind of an OTP right here because the account ID is set to false. But for the time being, just so we can see what
3:33:43
we're developing, I'll render this if it's true. So the OTP model appears on the bottom. Of course, right now the OTP
3:33:50
model is not a model quite yet. It is just a piece of text, but the goal for this lesson is to turn it into a modal.
3:33:57
And to do that, we'll use Shatien's alert dialogue that when you click it, it'll show some kind of a modal. So with
3:34:05
that in mind, we can follow the installation by heading over to our terminal and then pasting MPX shaden at
3:34:11
latest add alert dialogue. And you can just press enter to use force. And now we can copy its usage. So
3:34:19
right here at the top we have the imports. And then right within the JSX I can actually render the alert dialogue.
3:34:27
And that's it. That's how you create a dialogue. Can we see it in action? Well, click open. And there we go. It's super
3:34:34
easy to do things with CHN, but it's going to be even easier because we're going to pair this model with an input
3:34:40
OTP accessible onetime password component with copy and paste functionality. So now you can simply
3:34:46
type in your keyword and that's it. To install it, we can once again just run a
3:34:52
command. And I just noticed that we didn't continue with the rest of the questions Shhatzen asked me. So I'm just
3:34:58
going to press Y for yes. And I'll run MPX shaden at latest add input OTP.
3:35:05
Again, we'll have to answer two of the same questions. It's quite likely that by the time you're watching this video,
3:35:10
you won't even have to do that. But now, as you can see right here, for this to
3:35:16
work, we have to add some things to our Tailwind config. So if we head over to our Tailwind config and search for key
3:35:23
frames, you can see that I already added this beforehand. So we should be good. And after that, we can just import it
3:35:30
and use it. So let's do just that. Right at the top, I'll copy all of the
3:35:35
imports. And right here, I'll copy the input OTP. So where are we going to use
3:35:41
it? Well, we're going to use it below the alert dialogue header. So here the
3:35:48
alert dialogue header ends. And then right here above the alert dialogue footer. So I'll simply paste what I
3:35:54
copied. And that's it. If I go back, you can see something that looks like an OTP modal. Of course, we're going to style
3:36:00
it further and make it look so much better. So let's do that. Starting from the top, we have the alert dialogue, but
3:36:07
in this case, I want to manually manage its state by creating a new use state
3:36:12
field. So I'll say use state and I'll call it is open set is open at the start
3:36:19
set to true because once we have the account ID we want to make sure that it is already visible. Next we have another
3:36:25
state which is going to be the value of the one-time password. So I'll call it password set password at the start set
3:36:31
to an empty string. And finally we have the loading state. So I'll create a new use state field with is loading set is
3:36:39
loading at the start set to false. Of course, a form wouldn't be a form if we didn't have a submit handler. So, I'll
3:36:46
say const handle submit is equal to an async function that accepts an event
3:36:52
which is going to be of a type react. Mouse event, specifically an event on an
3:36:59
HTML button element just like this. And make sure to import react from React.
3:37:05
And then at the start, we can prevent the default because you already know the default behavior of the form. when you
3:37:11
submit it, it reloads. We don't want to do that. Next, we want to set its loading value to true. And then we want
3:37:17
to open up a try and catch block. In the catch, we have an error where we simply
3:37:23
want to console.log the error. Or we can do something like, you know, failed to
3:37:30
verify OTP. There we go. At the end, we'll set is loading to false. Whatever happened,
3:37:37
we are no longer performing any kind of OTP action. And in the try, this is
3:37:42
where the magic happens. This is where we want to call an API to verify the
3:37:47
OTP. So, we'll do this very soon, just after we complete the UI that would actually allow us to do so. And also,
3:37:54
you know how some users might not do it on time when they get the first email. So, we're going to also create a
3:37:59
function that would handle resend OTP. So in that case if they don't manage to
3:38:05
do it on time or if the first email is for whatever reason not there in that case we can just resend the email. So
3:38:12
I'll just say call API to resend OTP. Great. And now we can focus on the UI on
3:38:20
this alert dialogue. We can pass the open state which is going to be equal to is open. And on open change will be set
3:38:27
to set is open. That's going to make it always opened because is open is always
3:38:33
true. Next, in this case, we don't need the alert dialogue trigger here. It'll be triggered programmatically once the
3:38:39
user clicks the submit button. After that, we have the alert dialogue content with a class name of shad alert
3:38:47
dialogue. Next, we have alert dialogue header with a class name of relative
3:38:53
flex and justify center. Next, there's an alert dialogue title to
3:38:59
which I'll give a class name of H2 and text- center. And we're going to say
3:39:05
something like enter your OTP onetime password. Below the text, we can also
3:39:10
render an image. And this image will have a source of forward slassets/icons/clo--dark.svg
3:39:20
SVG with an AL tag of close, a width of about 20, a height of
3:39:28
about 20, an on click of set is open to false. So, we
3:39:35
want to close the model, and a class name equal to OTP close button. If I
3:39:42
save this, you can see a little close button at the top right, which would close the form. Next, let's mess with
3:39:48
the description a bit by giving it a class name equal to subtitle- 2 text-
3:39:55
center and text- light 100. And here we can say something like we've sent a code
3:40:03
to we can open up a span and then say email. And this email of course is
3:40:09
coming from props because we have passed them into our OTP model from the odd form component. So let's dstructure
3:40:16
them. I'll get the account ID as well as the email and these will be of a type
3:40:23
account ID is of a type string and email is of a type string as
3:40:30
well. Okay, that is great. Now we can say we've sent a code to and in this
3:40:36
case we actually cannot see an email. That's because we're still testing the model. Typically, you would never see
3:40:41
the model as soon as you open the sign up page at the moment when the user hasn't yet entered their email. But in
3:40:47
this case, we can see it because we're testing it. But later on, the email will always be there as it'll be picked up
3:40:54
from the form. So, we're okay here. Also, we can escape the apostrophe sign
3:40:59
right here by using this combination of letters. And for this span, let's give it a class name of padding left of one
3:41:06
to divide it a bit from the left and text dash brand just to show you how that would
3:41:12
look like. It's something like contact atjsmastery.pro. There we go. That's going to be very nice. For now, I'm
3:41:20
going to leave it dynamic. So once the user is actually filling it out, we can nicely show it. Next we have the input
3:41:26
OTP with a max length of six with a value of password and an onchange we
3:41:32
simply want to call set password. We have an input OTP group to which I'll
3:41:38
give a class name of shadotp and then I will remove the second group and the separator because
3:41:44
we want to show all six in the single group just like this. Now, as you can
3:41:50
see, that's going to kind of separate them a bit, but we want to make them appear more together. So, I'll hold the Alt key on my keyboard and select these
3:41:58
different lines. And then I can type the same thing in all six lines, such as a class name of
3:42:06
shad-pot. And if I save it, you can see that now they have gotten a look that is more on brand and better matches our
3:42:13
design. This is beautiful. And again, the fact that we can just use Shhatzen
3:42:18
here to develop these very nice and very functional looking components for something that would typically take us
3:42:25
hours to develop is just out of this world. So yeah, just wanted to say that.
3:42:31
Now we can go to the alert dialogue footer and within it we can create a new
3:42:36
div that'll have a class name equal to flex
3:42:42
w-ool flex- call and a gap of four. Within it we can render an alert
3:42:50
dialogue action which is this one right here. And I'll give it an on click
3:42:57
property which is going to call the handle submit functionality. And it'll have a class name of
3:43:05
shadsubmit-bn with an h of 12 and a type is equal to button. If we do that now
3:43:12
you can see a nice continue. And in this case we don't even need the cancel because we already have
3:43:18
the close on the top. There we go. It can say something like submit. And within it, we can render a self-closing
3:43:25
next.js image with a source of forward
3:43:33
slashassets/icons/loader.svg with an al tag of loader, a width of 24, a height
3:43:39
of 24, and a class name equal to margin left of two to divide it a bit from the
3:43:45
submit text, and animate dash spin. And we can save it. And now we can
3:43:51
see the spinning thing. But we'll only show this when it's loading. So we can say is loading. And if that is the case,
3:43:59
only then do we display this image. Finally, for clumsy users that didn't get the first email or it ended up in
3:44:05
spam, we can go below the alert dialogue action and create another div. And this
3:44:11
div will say something like didn't get a code question mark. We can create a new
3:44:18
button that'll have a type equal to button, a variant equal to
3:44:25
link, a class name equal to padding left of one and text- brand, and finally an
3:44:32
onclick property of handle resend OTP. And then we can say
3:44:39
something like click to resend. Of course, we have to import the button from dot
3:44:46
/components. And we can escape the apostrophe character right here by using
3:44:51
this keyword. Also, we don't have to call this function immediately. We can just make it a function declaration.
3:44:57
Okay, this is looking good. But let's style it a bit better by giving this div a class name equal to subtitle- two
3:45:06
margin top of two text- center and text- light- 100. And if I save it, this is
3:45:14
looking much much better. We have a beautiful OTP model that looks great on
3:45:20
mobile but also looks great on desktop. I would dare to say even better. So with
3:45:25
that in mind, we are ready to submit our OTP form to actually try to verify the
3:45:30
action on the server. Okay. So let's implement the handle submit
3:45:35
functionality inside of which we have to call the verify secret server
3:45:41
action. So let's create it under actions user actions and below all of these send
3:45:49
email OTP and everything we're going to create a new one export const verify
3:45:56
secret which is going to be equal to an async function that accepts an account
3:46:01
ID and the password and we have to define the types account ID is of a type
3:46:08
string and the password is of a type string. as well. And finally, we can
3:46:14
open up a function block right here and get access to appreite account
3:46:22
functionalities by saying const account is equal to await create admin client
3:46:29
which we can call like this. As a matter of fact, let's put this into a try and catch block just to make sure that
3:46:35
something doesn't go wrong. So this will go into the try and in the catch we can
3:46:40
have a catch where we call a handle error failed to verify OTP. So once we
3:46:46
do have the client we want to generate a new session for that client by saying const session is equal to await
3:46:56
account.create session and to it we can pass the account ID and the password. Finally we
3:47:03
want to set that session to a cookie. So we can say await cookies coming from
3:47:09
Nex.js which we can call set and we want to set an app dash
3:47:16
session to session secret and we want to pass additional options such as a path
3:47:23
of forward slash http only set to true same site set to
3:47:31
strict and finally secure set to true. These are all some precautions we have
3:47:36
to make when generating a session and setting it to cookies. Finally, we can
3:47:42
return parse stringify. And then we want to simply pass an object with this
3:47:48
session ID being equal to session dot dollar
3:47:54
sign ID. There we go. So now we have a function called verify secret which we
3:47:59
can call within our OTP model. We can do that by saying const session id is equal
3:48:05
to await verify secret to which we can pass an object containing the account ID
3:48:12
and the password. Once we have it, we can check if session ID exists. And if
3:48:19
it does, we can use the Nex.js router functionality by declaring it above con
3:48:24
router is equal to use router coming from next navigation not next router. Be
3:48:31
careful about that. And we can simply say if session ID
3:48:37
router.push at push. Where do we want to push? To forward slash, meaning just go
3:48:43
to the homepage. And let's properly spell the router. And let's make sure we're properly mounting it. Cons router
3:48:50
is equal to use router. And as you can see, we have an error. Next router was not mounted properly, which is not
3:48:57
really a descriptive error enough, but it's enough for me to notice that I forgot to pass a use client at the top.
3:49:04
Considering that we're using forms and hooks and routers and more, it has to be a use client component. I'll also remove
3:49:11
these unused variables or imports coming from chat. I'll check my import. So
3:49:17
that's import use router coming from next. Oh, it looks like it imported it from router after all. And I said to
3:49:24
import it from navigation. There we go. We fixed it now. And we are ready to verify the
3:49:30
session and navigate to the homepage. And while we're here, before we try it out, let's also implement the handle
3:49:37
resend OTP. If we go to user actions, I think we had something similar. We had
3:49:43
send email OTP. Yep, it's right here. So, we can just use it. Let's go back to
3:49:49
the OTP and let's say await send email OTP. And to it, I think we just need to
3:49:56
pass an object containing the email. And let's make sure to properly import it. OTP. Oh, it looks like it doesn't want
3:50:03
to import it. It should be coming from user actions. So, I'll just put it here.
3:50:08
Oh, but it looks like we didn't export it. So, if I go back to user actions, we have to say export
3:50:15
const send email OTP. Before we were using it just in the create account to immediately send it. But if somebody
3:50:22
wants us to resend it, then we have to run export and then import it from here
3:50:27
and use it there. So, with that in mind, let's actually give it a go. I'll go
3:50:33
here and I'll say something like adrienjsmastery and I'll enter my email
3:50:39
contact atjsmastery.pro and click sign up. Immediately after that, it looks
3:50:47
like something has happened, but the OTP model didn't pop up. Let's see why is
3:50:52
that. If I head over to the O form, that's because we are currently setting the O form always to be true. But we
3:50:59
should only activate once the account ID is actually clicked. And the account ID actually
3:51:06
gets updated right here on the create account. So if I try it one more time,
3:51:11
you'll still notice that it fails. So let me actually expand this and open up the inspect element and the
3:51:18
console and click it again. And you'll see we don't really get anything right here. We do get a 200
3:51:25
from in our network tab, but other than that, not much more is happening. It
3:51:30
might be because I tried to use this email before. So, let me reload the page and I'll try it once
3:51:38
again and click sign up. There we go. Now it appears. Since we made a change
3:51:44
in the odd form right here where I specified account ID, I actually had to
3:51:50
reload the browser because the change was on the client side. Now go to your email and you should see a couple of
3:51:55
emails because I clicked a few times, but you should go for the latest one right here, which is this one. I will
3:52:02
copy it and you can manually type it. But what you can do is just paste it. So
3:52:07
I'll paste it and click submit. And there we go. we got redirected to the
3:52:13
forward slash route or the homepage. And what does that mean? Well, if you check the OTP model, we would only get there
3:52:21
if we don't fail the try block. So, we didn't get this error and only if the
3:52:27
session ID exists. So, that means that we have successfully generated a user session. And if you head over to inspect
3:52:33
and go to application and go to cookies localhost, you should notice the apprite
3:52:39
session right here. But I noticed something that is not quite good. The value of that session actually seems to
3:52:46
be empty. Interesting. So this is definitely something that we need to
3:52:51
further investigate. But for the time being since we don't even have the logout option, we cannot go back to test
3:52:58
out the login. We can only do that manually by changing the URL. But I think now is the right time to develop
3:53:04
the layout of our actual application. And that includes the navigation bar as well as this beautiful sidebar with
3:53:11
different links. And at the bottom, we have more info about the user. So when we try to fetch that, we'll see if the
3:53:17
session has indeed been created or not. And then also at the top right, we have a logo button so we can continue testing
3:53:23
the O. But for the time being, let's focus on the homepage
3:53:29
layout. To get started with creating our layout, we'll follow a similar process
3:53:34
like we did for our authentication routes. Remember how we had a route group within which we had the layout and
3:53:41
then the two pages that share that layout. We'll do the same thing for the homepages. So let's create a new route
3:53:47
group which is going to be a folder whose name starts with parenthesis which is root for the route group. And within
3:53:55
it we can create a new layout.tsx tsx file. This layout will be a React
3:54:02
functional component. And as with any layout, it'll accept children, which will be of a type react node. It'll
3:54:09
render a single main tag since we're showing all the main content within it with a class name equal to flex and age-
3:54:19
screen. And then within it, we will render a sidebar. Below the sidebar, we'll render a section that'll have a
3:54:26
class name equal to flex hash- full flex-1 and flex- call inside of which
3:54:35
we'll render the mobile navigation as well as a header. And
3:54:40
finally, within it, we'll have a div with a class name equal to
3:54:46
main-content inside of which we'll render the children. If I save this, you'll notice that the look and feel of
3:54:52
our primary homepage didn't change. That's because we have to move this page right here from the app folder to the
3:54:59
root folder. If you do that and reload, you'll notice that now it'll have space for the sidebar as well as the mobile
3:55:06
navigation and the header. And the content will appear right here in the middle. Now, let's create these
3:55:11
components, the sidebar, the mobile navigation, and the header. We can do that by creating all of these as new
3:55:18
files within the components folder. First one called sidebar.tsx within which I can run
3:55:25
rafce. The second one can be called mobile
3:55:30
navigation.tsx inside of which we can run rafce. And finally the third one can be
3:55:36
called header.tsx inside of which we can run raftce.
3:55:42
Now we can import and use all of these three components such as sidebar which
3:55:47
we can import from components sidebar. Next we can get the mobile navigation. So let's make sure to import it properly
3:55:54
as well. And finally we can render the header which is going to be another self-closing component which we're going
3:56:01
to import from components header. There we go. You can see everything is still working exactly as it did before. So,
3:56:08
what do you say that we start with a header since it's going to be most prominent right here at the top? Let's
3:56:13
dive into the header component and let's start implementing it by turning it into an HTML 5 semantic header tag with a
3:56:22
class name equal to header. Within it, we can render just a keyword that says
3:56:27
search. Later on, we'll implement a real global search out of this. That's going to be quite an exciting lesson. So stay
3:56:34
tuned because it'll allow us to search across all the files, all the pages, all
3:56:39
the content in our database. Below it, we'll have a div with a class name equal
3:56:45
to header-wrapper. And within it, we can render our file uploader component. More
3:56:52
on that soon. This will be a button that allow us to upload the files. And within it, we can have a form. This form will
3:56:59
render a button. This button will be of a type is equal to submit and a class
3:57:05
name equal to sign out button. And now within that button we can render an
3:57:12
image. And this image will have a source of for/assets/icons/loout.svg
3:57:20
SVG with an al tag of logo, a width of 24, a height of 24, and a class name of
3:57:31
W-6. If I save it, it's almost as if we cannot see this header appear anyway
3:57:36
because we're on mobile, right? So, we can only see the mobile navigation. But if we expand a bit, you can start seeing
3:57:43
the header on tablet or desktop devices. So now we have the search, the file
3:57:48
uploader, and the logout button. While we're here, we can also create what are soon going to become the components for
3:57:55
search and file upload. In the similar fashion, we created these three. So I'll create a new component called
3:58:02
search.tsx. Run rafce. And I'll do the same thing with the file uploader by creating a new file
3:58:10
uploader.tsx file inside of which we can runce. So now we can simply import and render
3:58:18
both of these components. The search coming from components search and the
3:58:24
file uploader coming from component search as well. Nothing has changed but
3:58:29
now we can dive into these components and implement them one by one. But with that in mind, we now have something that
3:58:35
at least looks like the final layout. Well, maybe not yet. After we implement the sidebar and the mobile nav, it'll
3:58:42
look a bit better, but at least it resembles the UI that we'll soon have. So, to make it look much nicer, let's
3:58:48
implement the sidebar. For the sidebar, we'll have to keep it at at least a tablet width, which is going to look
3:58:55
something like this. And as a matter of fact, since the sidebar is on the left side, I'm going to switch the position
3:59:01
of my code editor and the browser. That way, we can see it while we're implementing it. So let me head over to
3:59:08
the sidebar component and let's implement it by using an HTML 5 semantic aside tag which means that this is going
3:59:14
to be a side navbar and we can give it a class name equal to sidebar. Within it
3:59:20
let's render a link coming from next link with an href of forward slash
3:59:25
meaning pointing just to home. And within that link, we can render an image that's going to be an X.js image tag
3:59:31
with a source of forward slash assets/icons slash
3:59:41
logo-fool-brand.svg with an al tag of logo. And we'll have to give it a width of about 160 and height of about 50 with
3:59:50
a class name of typically hidden with an auto height. So, h- auto and it'll be
3:59:56
visible on larger devices. So, LG block. Once we do that, you can see we cannot
4:00:02
see it yet because we're not on a large device. But if I expand a bit more to get to the large screen, you can see
4:00:08
it's right here. Great. So, I can extend my code editor because the only thing we care about is the sidebar for now, which
4:00:15
we can visually see because it's on the left side. But below this image, I'll render another image. And this one will
4:00:21
be logo but for smaller screen sizes. So we can see source is equal to
4:00:31
slassets/icons/logo-brand.svg with an al tag of logo a width of 52 a height of 52
4:00:38
and a class name of lg hidden. So we're doing the exact opposite as before. So
4:00:45
now if I go here and collapse it, you can see this smaller one right here. Looking great. Now let's create a navbar
4:00:53
right here below the link. That's going to be a nav tag with a class name equal
4:00:59
to sidebar-nav. And within it, I'll display a ul, an unordered
4:01:06
list. It's going to have a class name equal to flex.
4:01:12
And I have to properly spell the class name here. It's going to have a flex dash one, flex- call, and a gap of six.
4:01:21
Within it, we need to display our nav items. Now, we could manually create an array here and then create a couple of
4:01:28
objects where we have name and then we have a path. But this would simply clutter our view because we would have
4:01:34
to have all of the objects right here. What I prefer to do instead is to create a constants file that looks something
4:01:41
like this. You can create a new constants folder right here in the root of our directory and within it you can
4:01:49
create a new index.ts RTS file and there we can define all of the things that we
4:01:55
might use across some places like export con nav
4:02:01
items is equal to an array where we have the name of each link such as in this
4:02:08
case dashboard. Each link also could have maybe an icon which in the dashboard
4:02:16
case would be assets icons dashboard. SVG and it also needs to have
4:02:23
a URL to which it will point to which is just going to be forward slash because our home is our dashboard. And that
4:02:30
looks something like this. So now you need to duplicate it and create it for all other pages such as documents,
4:02:37
images, media and others. So we can display the different links right here. Of course, I'm referring to the links
4:02:44
from the design, documents, images, media, and others. Feel free to take the
4:02:50
time to write some of these routes, icons, and names. But just to save you some time, in the description down
4:02:55
below, you can find the GitHub readme where you can find the code snippets. And one of them will be the constants
4:03:01
index.ts file. So here, I just provide you with all the links. No logic here,
4:03:06
just some code that's easily copyable. Great. So once you have it, we can use it within the sidebar to map over it. So
4:03:14
let's say nav items coming from constants dot map where we get each
4:03:20
individual item and for each one we want to open up a code block and then figure
4:03:25
out whether it's active or not. So we can say it's active if path name is
4:03:31
triple equal to the item URL. And this path name refers to the path name we're
4:03:36
currently on. And to figure that out, we have to use the use pathname functionality from Nex.js by saying
4:03:43
const path name is equal to use path name coming from next. Once we do that,
4:03:49
we can now compare it and we have to turn it into a client component because we have used a
4:03:55
hook and sidebar should be client anyway because we'll use redirects and actually
4:04:01
route people to different links. So now that we know which link is active, we can actually return a link. So we can
4:04:08
say return a link component which of course has to be imported from next. And we can give it
4:04:15
an href equal to item URL. And as a matter of fact, let's actually dstructure those properties like the URL
4:04:21
and so on from the item. So we have the URL, we have the name and we have the
4:04:27
icon. So now instead of saying path name is equal to item. URL, we can just say
4:04:33
URL. Same thing here for URL. And active is actually pretty short. So we can just
4:04:39
use this equation instead of setting it to a new variable, which would allow us to just have an immediate return of a
4:04:46
link just by wrapping it in a parenthesy instead of in a function block. So
4:04:51
that's how immediate returns work. Next, within this link, we can render an LI that'll render an image with a source of
4:05:00
icon, an al tag of name, a width of 24, a height of 24, and that's it. And
4:05:08
below it, we can render a P tag that'll render the name. If I save this, you can
4:05:14
see something that resembles our URL structure. Let's give each link a key
4:05:20
since we're mapping over them. and a key will simply be the name since each name is different. Let's also give it a class
4:05:27
name on large devices wful. Let's also style the li by giving it a class name
4:05:34
equal to. We can use the CN property from shad CN and within it we can give
4:05:40
it a sidebar-nav- item and then as the second parameter we can say only if path name
4:05:48
is equal to URL in that case give it a shad active class let's properly name
4:05:54
this path name and let's specify an end sign here so only if this is true which
4:05:59
we have to wrap in parenthesis right now then give it a shot active and now you
4:06:04
can see this is looking a bit better. Let's also style the image by giving it
4:06:10
a class name equal to. We'll once again use the CN right here. And every image
4:06:16
will have a nav icon property, but only if path name is triple equal to URL. Then we'll
4:06:26
also give it a nav icon active. And let's properly spell class name here.
4:06:31
And now we can see that it turns white when it's active. but it's gray
4:06:37
otherwise. Let's also style the P tag by giving it a class name of typically
4:06:43
hidden but on large devices block meaning visible. So check this out. If
4:06:48
we're on desktop devices, we have enough space for the sidebar. But if we collapse it to tablet, check this out.
4:06:56
So nicely collapses. And this is the homepage, the dashboard. We have the files, images, videos, and others.
4:07:03
Everything makes so much sense. Beautiful. Now let's head below this ul
4:07:08
and below the nav and let's create a new image. This image will have a source of
4:07:16
for/assets/ images/files-2.png. For the al tag let's
4:07:24
say logo. For the width let's do 506.
4:07:29
For the height, let's do 418. And let's give it a class name of w-f
4:07:37
full. And we can close it right here. This is just a nicel looking files icon.
4:07:43
And it's going to create some separation to show our user details. So just below the image, let's render a div with a
4:07:51
class name equal to sidebar- user- info. within it render an image with a source
4:07:59
of and we can use the same placeholder image that we already used once. I'll try searching for it by searching for
4:08:05
placeholder. No, maybe it was avatar. Yep, this one from Pixabay. Since it's a
4:08:11
long name, I can actually put it into constants. So, go ahead and copy it. Head over to the constants folder and
4:08:18
index.ts. And let's just create this new const avatar placeholder URL and make it
4:08:26
equal to this one right here. And don't forget to export it. And now I can use the same one right
4:08:32
here in user actions avatar placeholder URL. And we can use it in the sidebar.
4:08:39
That's going to be source avatar placeholder URL. The all tag will be
4:08:45
avatar. The width will be 44. The height will be 44 and a class name will be
4:08:52
sidebar user avatar. I've decided to use static avatars right here because this
4:08:59
app is not really user based like social media applications where you have to change your avatar every now and then.
4:09:04
Here what we care about the most is what's inside of our account which are the files we upload. Now you'll notice
4:09:11
that our app will break saying that cdn.pixabay.com pixabay.com or whatever other source of the image you chose will
4:09:18
not be accessible right here. So you have to head over to next.config.ts and you'll have to
4:09:25
specify images remote patterns and within it provide an array of an object
4:09:32
where you specify a protocol of https and then below it you provide a host
4:09:39
name of cdn.pixabay.com pixabay.com and later on once we want to
4:09:44
read additional images we'll also need to add apprite. So let's do it right now. Protocol https and
4:09:55
cloud.apprite.io. Now if we reload you can see that now we can see the image and we have a placeholder icon right
4:10:01
here. I might actually decide to change it later on because this one looks a bit too default but that's okay for now.
4:10:08
What I care about much more though is going to be the user details. So let's create a div that'll typically be
4:10:15
hidden. So it'll have a class name of hidden. But on large devices it'll be visible. So it'll have a class name of
4:10:21
LG block within it. We can display a P tag
4:10:26
with a class name of subtitle- two and capitalize. And we can render the full
4:10:34
name. But the question is where's this full name coming from? And I mean same things
4:10:40
goes for the email. So if we render a P with a class name of caption and try to
4:10:45
render the email, we don't yet have access to these things. Remember what I
4:10:50
said before, these need to come from the session. So where are we going to get access to this session? I don't want to
4:10:57
get access to it right here within the sidebar because we'll have to use it in other places too. So let's head to the
4:11:04
central place where we'll need to use it and that's going to be in the layout root because this place supplies both
4:11:12
the sidebar, the mobile nav, the header as well as all the other pages. So here
4:11:17
we have to try fetching the current user. But we can only fetch it if we create a server action that allows us to
4:11:24
do so. So for now our app is broken, I know, but let's head over to
4:11:29
user.actions.ds. DS and below verify secret we can create
4:11:34
a new function that will allow us to fetch the current user. So let's say
4:11:40
export const get current user is equal
4:11:45
to an async function. We have to get access to databases as well as the account which is equal
4:11:52
to await create session
4:11:57
client. Then we want to get the result by saying const result is equal to await
4:12:05
account.get. And then we want to extract the user from the database by saying const user is equal to await
4:12:13
databases.list documents. And here we have to specify from which database we want to get it from which collection we
4:12:20
want to get it and what is the query to fetch it. So conveniently enough my code editor autofilled it for me. First want
4:12:27
to provide it the appreate config database ID. Then we want to provide it the user collection ID. And finally we
4:12:35
want to write a query where we are looking for a result dollar sign ID that
4:12:41
matches the account ID. And this doesn't have to be in an array. It can just be
4:12:47
like this. That should give us access to the user. And then we can check if a user exists or if user.total total is
4:12:55
lower than or equal to zero then we can return null but else we can return parse
4:13:02
stringify user documents zero which should bring us back the currently
4:13:08
active user. So now we can use this server action right within our layout by
4:13:14
saying const current user is equal to await get current user and don't forget
4:13:22
to make this function async since we're using a weight and also if there is no current user in that case we can return
4:13:31
a redirect coming from next navigation and we want to point the user to forward
4:13:36
slash sign-in make sure that this redirect is coming from next navigation
4:13:41
and not whatever it imported right here. So I'm going to say redirect. So I'll import it by saying
4:13:48
import redirect from next navigation. There we go. And now we can reload and
4:13:56
see what's happening on the server. We are getting server error no session. And
4:14:03
this is coming from create session client. So that's in the user.actions.ds.
4:14:08
DS specifically from the create session client. That's this function right here. That is saying that right now we don't
4:14:15
have the app right session created which is exactly what I assumed when I check the cookies because we saw that the
4:14:23
cookie value wasn't actually added. So let me head back over to sign up
4:14:29
functionality right here in the signup page and we'll have to head over to the odd form. In the odd form, when we're
4:14:36
creating a user, we're calling this server action. And that server action creates an admin client. And to set up
4:14:42
the admin client, we're using these specific env. So let's check if we set them up right. We have the endpoint URL
4:14:50
which points to apprite endpoint project ID which points to apprite project. And
4:14:57
I believe we used a secret key which points to apprite key. So now I have to
4:15:02
compare them with our env side by side. Starting with the
4:15:07
endpoint URL, we call it next public apprite endpoint. That's correct. Next
4:15:12
we have the app right project. And finally, it looks like I misspelled the secret key. Here I called it apprite key
4:15:20
and here I'm calling it apprite secret. So let me actually fix it by renaming my
4:15:25
env to say next apprite key.
4:15:31
There we go. So now this env should be good and we should actually successfully be creating a session. I'll go to
4:15:38
inspect element and go to the application tab and I will completely clear the
4:15:43
cookies as well as the local storage and the session storage. Then I'll head over
4:15:48
to sign dash up and make sure to delete all the existing users by heading over
4:15:54
to O and then clicking on them heading all the way down and then deleting them.
4:15:59
just to make sure that we have a clean and empty slate. There we go. Now that that is deleted, let's also clear up our
4:16:05
database by heading over to databases and then users and simply select all
4:16:10
three of these users and simply delete them. Now we can try creating a new user. I'll call it
4:16:17
Adrianjsmastery and I'll use my contact atjsmastery.pro email and I'll click
4:16:22
sign up. There we go. An OTP has been sent. I'll make sure to copy it and I'll
4:16:28
paste it right here and click submit. Immediately we are redirected back to localhost which is a good sign. But
4:16:35
right now we're not getting that session not found error. Right now we are exactly where we left off in the
4:16:41
sidebar. Remember if I head back over here we were trying to console log two
4:16:47
different things. The full name and the email even though we knew that we have to extract them from somewhere. So this
4:16:53
entire time we have been trying to log our user in and get the active session
4:16:58
so that we can extract the full name and the email from the session. Our sidebar is being called within the root layout.
4:17:06
So let's head over to root layout which is this one right here. And remember
4:17:11
here we're trying to access the current user by calling this server action which should give us all the information about
4:17:17
the currently active user. And then once we get it, we are ready to pass it over
4:17:23
to the sidebar. So let's do just that by passing the full name is equal to
4:17:29
current user.name. Let's also pass the avatar image equal to current user avatar. And
4:17:37
now that I think about it, we're just simply saying full name is equal to something that same thing. Same thing
4:17:43
here. So instead of doing that, let's simply spread the entire current user, which is going to look something like
4:17:50
this. Object da current user. Now we can head into the sidebar
4:17:57
and we can accept all of these props we're passing in such as a full
4:18:02
name. We can also get the avatar and we can get the email. And those can be of a
4:18:08
type props which we can define right here. interface props is equal to full
4:18:16
name is of a type string. Avatar is of a type string and email is of a type
4:18:24
string as well. And now, as you can see, we're back here and we're successfully
4:18:30
rendering the full name and the email right there. And while we're here, we
4:18:35
can also render the user avatar by simply rendering the avatar. It's not like anything will change because we're
4:18:41
still using this demo placeholder avatar which we can later on switch with some kind of a more interesting avatar image.
4:18:48
But again, I mean, just check this out. Now we are successfully logged in. We know which user is logged in and we have
4:18:55
a left sidebar that will soon allow us to navigate to other pages. Soon enough,
4:19:00
we'll also head back over to complete our header with its search file uploader
4:19:05
and the functionality for the logout button, which so far hasn't been implemented yet. But next, let's focus
4:19:12
on the mobile navigation. What happens if I collapse my screen to a mobile size? Well, as you can see, we have no
4:19:19
space left for the left sidebar. So that means that I can head over to the mobile
4:19:24
navigation component and I can collapse it a bit just so we can see our browser.
4:19:30
So let's implement the mobile navigation next to develop our mobile navbar we'll
4:19:36
need to use another shatzian component specifically a chaten sheet which is a
4:19:42
dialogue component that extends to complement the main content of the screen something that looks like this.
4:19:49
So let's go ahead and install it by running this command in our terminal. MPX shaden at latest add
4:19:57
sheet. Press Y and install all the dependencies. Let's copy its usage right
4:20:03
here at the top. And let's copy the rendering part. I'll simply first wrap it in a header. So let's create a header
4:20:09
component. Within it, I'll create an image coming from next image with a source of forward slash
4:20:20
assets/icons/logo-fool- brand. SVG with an al tag of logo, a width of 120, a
4:20:29
height of 52, and a class name equal to hash-
4:20:36
auto. And right below it, we can render the sheet that we just copied. So, let
4:20:42
me save it. And check this out. Now, we have a logo that says open. And then it
4:20:48
opens up right here. Looking great. Let's also give this header a class name
4:20:54
equal to mobile dash header. That's going to position the logo on the left side and the open button on the right
4:21:01
side. And now we can focus on working with this sheet. First of all, I'll create a new use state field. I'll call
4:21:08
it open and set open at the start set to false. This will also have navigation
4:21:14
items within it. We also need to know the path name. So I'll say const path name is equal to use path
4:21:22
name. And of course we need to import it from next navigation.
4:21:28
Now moving down to the sheet, we can pass it different props such as open is equal to open and on open change is
4:21:37
equal to set open. So that's going to modify this state variable. Sheet trigger is not going to
4:21:43
simply say open rather it'll be an image. It's going to have a source of
4:21:49
for/assets/icons/menu.svg SVG with an al tag of search, a width of
4:21:58
30, and a height of 30. If you save that, we have to properly import the use
4:22:04
path name right here at the top. Or should I say we have properly imported it, but instead we have to turn it into
4:22:10
a use client. So, let's use client. And we're
4:22:15
good. And now we can see that this looks much better than a text that says open. We have an actual burger menu right
4:22:22
here. Right below the sheet trigger, let's style the sheet content by giving it a class name equal to shad sheet
4:22:32
hash-screen and padding x of three. Next, we can remove the sheet header. We don't need it in this case, but within
4:22:39
our sheet title, I'll create a new div that'll have a class name equal to
4:22:45
header-ash user. And I'll render an image with a source of avatar, an al tag
4:22:51
of avatar, a width of 44, a height of 44, and a class name equal to header-
4:23:01
user dash avatar. Of course, we're not yet passing this avatar into here, and we're also
4:23:08
not passing the full name and everything else that we need from our user. So, let's go ahead and pass it. Remember,
4:23:14
we're calling this right from the root layout, same way in which we're calling the sidebar. So, let's simply spread all
4:23:21
the information about the current user into the mobile navigation as well. Next, we can simply dstructure all of
4:23:28
those fields by getting the owner ID. I believe we have access to that account
4:23:33
ID, full name, avatar, and email.
4:23:39
And this is going to be equal to props. And now we can define those
4:23:45
props right here by saying interface props. And we're going to have an owner
4:23:51
ID of a type string, meaning who owns a specific file, an account ID of string,
4:23:58
full name, avatar, and email, all strings. So now if you open it up, you
4:24:03
can see an actual avatar image. And if we go down right below the avatar
4:24:09
we can render a div. And this div will have a class name
4:24:15
of on small devices this will be hidden but on large devices it'll be block
4:24:20
meaning shown within it. We can render a p tag that'll render the full name. And
4:24:27
we can also give it a class name equal to
4:24:33
subtitle-2 and capitalize. There we go. This is looking great. And right below it, we can also
4:24:40
render another P tag that'll have a class name equal to caption and it'll
4:24:46
render the email. So if I fix this and save it, this is looking great. Now we
4:24:54
can go two divs down and we can install a chaten separator component. So that's
4:24:59
simply separator. I think this is the simplest component to use. You just
4:25:04
simply say separator import it from components UI separator and save it. You
4:25:10
can also give it a class name of margin bottom of four and bglight 200 over 20.
4:25:18
And as you can see, this created some separation from the top content and the content below. Now we can exit the sheet
4:25:25
title. And right below it, we can delete this entire sheet description. And I'll
4:25:31
create a nav that stands for navigation bar that'll have a class name equal to
4:25:40
mobile-nav. And within it, we can create a new ul, an unordered list that'll have
4:25:46
a class name equal to mobile-nav-list. And within it, we can
4:25:52
map over our nav items. So let's say nav items coming from constants. Remember
4:25:58
this is a list of different URLs that we have within our application that we have created earlier and now we can map over
4:26:05
them almost in the same exact way of how we have done it in the navigation bar.
4:26:10
So if I open up the sidebar we can copy this part where we have nav items.m
4:26:16
map. So let me copy it. And now I'll paste it right here. There we go. Of
4:26:22
course it'll require some fixes because we're doing mobile here instead of desktop. First, we have an href with a
4:26:28
name URL and LGW fool. Then we have a list item with mobile nav items. So,
4:26:35
let's fix this CN class. There we go. That's going to change the layout. Then, we have the image where it says nav icon
4:26:42
and nav icon active. This is looking good to me. And finally, we have a P tag, which is not going to be hidden in
4:26:48
this case because even though we're in mobile, we have enough space to show it. So, this is looking great to me. Now we
4:26:55
can head down right here below the nav and create another separator. We'll do it exactly as we
4:27:02
have done the last one with a class name of margin y of five to create some space
4:27:08
in top and bottom and bglight of 200 over 20. Now we can create another div
4:27:14
right below the separator that'll have a class name equal to flex flex-
4:27:22
call justify dash between a gap of five and a padding
4:27:28
bottom of five and within it we will render a file uploader. So soon enough
4:27:33
we'll be able to upload the files from here and right below it we're going to have a button to sign out. Since this
4:27:39
one is similar to the one in the header, I will simply go ahead and copy this button. Go back here and render it right
4:27:47
below the file uploader button type submit with a class name of
4:27:53
mobile- sign-button. It'll have an on click,
4:27:58
which soon enough we'll be able to use the real logout functionality. For now, we'll make it an empty callback function
4:28:05
and it'll have an icon that's going to say log out. We can just remove this W6 for the width. And there we go. We have
4:28:11
a beautiful button. And we can also add a text, a P tag that simply says log out
4:28:17
right here below. And over here, let's also use the file uploader component we created before. That's just file
4:28:24
uploader. Nothing will change right now because it's still just an empty piece of text. But once we start implementing
4:28:31
the file uploader on desktop, this one right here, it'll also automatically work for the one in the mobile
4:28:38
navbar. Now that we've implemented the mobile navbar, we are finally ready to implement the functionality for the log
4:28:45
out both on mobile and on desktop. And once we implement that we'll also have
4:28:51
to finalize our authentication specifically the log in part of the O because right now we have only
4:28:58
implemented register. So let's do that next to implement our logout
4:29:05
functionality. I want to introduce you to a new tool from AppRight called the assistant that allow you to implement
4:29:11
different features, APIs, and more by generating some code for you,
4:29:17
specifically helping you with the queries and optimizations. So, how can you use it?
4:29:22
It's super simple. Just head back over to your dashboard, press control or command K, and then just say ask the AI.
4:29:30
And now we can ask it any kind of question like how to implement an OTP
4:29:37
login form. And check this out. It's going to figure out that you need to
4:29:42
create a new apprite client by getting all of these environment variables. Initiate the OTP authentication by
4:29:50
creating a magic session URL. And then you have the form and finally you have to handle the form submission to create
4:29:56
a session which is exactly what we have done. Of course, you'll have to tweak it to match your codebase, but what I love
4:30:02
the most about it is that it actually creates sources for you. So, you can very quickly refer to these different
4:30:07
links that make it happen. In this case, I'm wondering how can we log the user out? So, I'm going
4:30:14
to say how can I log my user out? So, to log a user out, you can use
4:30:23
appite.delete session. This is exactly what I wanted. It helps us specify the
4:30:29
client and then it has a function that deletes a session. This is all that I needed. So I'll copy this part delete
4:30:36
the current session and I'll head back over to
4:30:41
user.actions.ts and I'll say export const sign out user is equal to an async
4:30:49
function where we have a try and catch block and in the try we'll try to delete
4:30:55
the session. Of course, this account is coming right here at the top by saying await create session client. Then we can
4:31:03
await account.delete session. And we don't need to use the doc then since we're using async await. After we delete
4:31:10
the session, we want to delete it from the cookies too. So we can say in parenthesis await cookies and then
4:31:19
delete and specifically want to delete the apprite session. Finally, let's add
4:31:24
a catch block. Within catch, we're getting the error. And then we can call the handle error saying fail to sign out
4:31:31
user. And finally, we have a finally block, no pun intended, which can simply
4:31:37
redirect our user. So, let's redirect the user to sign in. Now, it looks like
4:31:42
I forgot to apply a semicolon here. If I do apply it, this is going to be good
4:31:48
because these are two distinct lines of code. So with that in mind, now we have the sign out user functionality and
4:31:54
let's head over to our mobile navigation to just add it to this on click. It's
4:32:01
going to be simple. You just make this function an async function and then you
4:32:06
await sign out user and you call it like so. Now remember we are going to also
4:32:12
implement it within our header right here where we click the log out button. But in this case it'll be just a tiny
4:32:19
bit different. See our header component is not a client component. It is a server component. And
4:32:26
for that reason, you cannot really use client side functionalities like button clicks or form submissions or redirects
4:32:33
for that matter. So that's why we'll use new React 19 functionality by passing an action to a
4:32:41
form that will allow you to perform a server side functionality for what seems to be a client side thing. We can do it
4:32:49
by creating a new async function and then opening a new block of code adding
4:32:55
the use server directive. So that means that the code below this code will be rendered on the server and we can call
4:33:01
the await sign out user like so. Now if you head back and if you click log out
4:33:08
you can see that we've been successfully logged out from our application and we can soon start implementing the signin
4:33:14
functionality. But just before we do that, remember that ugly avatar icon that I decided to
4:33:20
use? Well, let's just fix it so that the new users that are coming to our platform have a bit nicer avatar images.
4:33:27
I'll go ahead and choose this guy right here. Seems to be working well with our 3D theme. So, I'll simply copy the image
4:33:34
address. You can choose any other avatar you want. Or what I would even like you
4:33:40
to do is implement another modal where you allow your users to choose from multiple different avatars. Or this is
4:33:46
pretty cool. You can use appite's avatars functionality that will allow you to generate an avatar image based on
4:33:53
the letters of their first and last name. That's also pretty cool. But in this case, I'll go back and I'll go
4:34:00
where we are creating the user, which is going to be in user actions.
4:34:05
And we're creating the user somewhere here. There we go. And I'll simply want
4:34:11
to update the avatar placeholder ID from this pixabay one to this new one coming
4:34:18
from freek. And I already know that we'll have to head over to config nex
4:34:24
next.js. And we'll have to add another remote pattern right here to tell next.js that it's fine to render an
4:34:30
image from this source. Great. Now I'll go ahead and create a new account. Let me use the
4:34:37
same name as before, but this time I'll use a different email. There we go. We
4:34:42
now have to verify it. And immediately after verification, we're back. We have
4:34:48
to configure it. That's imagefreepic.com, which we have to add
4:34:53
to our next.config.ds. I reload it and we're good. Yep, this is looking more like it.
4:35:00
until I do the official face reveal. I'm more than okay with this. Now, let's log out one final time and let's implement
4:35:07
the signin functionality. I'll try to ask the app right assistant one more time by pressing command K and then ask
4:35:14
the AI and I'll say how can I implement a Nex.js server action that will sign in
4:35:23
the user using OTP. Let's see what it says. Okay, it does everything we've
4:35:30
done before. Create admin client. Create the OTP signin server action. Yep, this
4:35:36
is looking pretty good, I got to say. It's using the cookies. It's using the NexJS redirects, the create admin
4:35:41
client, and more. It's creating a session, setting the cookies. Yep, this is looking great. In this case, we have
4:35:48
already created the form and we have created a server action that will help us send out the OTP verification. So
4:35:55
let's just do it manually by heading over to user actions. I'll head below the sign out user and export const a new
4:36:03
one sign in user which is going to be equal to an async function that accepts
4:36:09
an email of the user we're trying to sign in and that email is of course of a
4:36:14
type string. We want to open up a try and catch
4:36:19
block. In the catch, we're going to get the error and simply handle that error by console logging it. And in the try,
4:36:27
we'll extract the existing user if it exists. So I'm going to say
4:36:33
constexisting user is equal to await get user by email. And then we pass the
4:36:39
email. And then if a user exists, we send the one-time password to their
4:36:45
email by saying if existing user then await send email OTP to this email and
4:36:53
immediately return parse stringify the account ID from that existing user. else
4:37:00
if it doesn't exist we can just return parse stringify and I'll return something like
4:37:07
account ID is equal to null and I'll also return an error that we can then
4:37:13
use by saying something like user not found and now we can use it within our
4:37:19
form so let's head over to our odd form head over to where we're creating the
4:37:25
account and we want to make a check right here right before we say where the user is coming from and right before we
4:37:31
make a decision whether we want to create or sign in. So I'm actually going
4:37:37
to add a new turnary operator is sign up
4:37:42
and if it is sign up I'll call this await functionality right here to create an account else I'll call
4:37:50
await signin user and to it I'll pass the email equal to values email coming
4:37:59
from the form and this is sign up is going to be true if our
4:38:05
type of the form that we're passing as props is equal to sign dash up. I'm
4:38:11
referring to this type right here. And let's make sure that we're properly closing it. Let's see. This function is
4:38:17
ending all the way here. So, I think I should have put my second part here. There we go. That's better. You can also
4:38:24
use an if if this seems a bit too overwhelming with these turnaries. So
4:38:30
using an if by saying something like let the user is null and then if type is
4:38:37
sign up in that case you can use this block of code else you can do another
4:38:43
block of code but that requires an additional variable assignment so in
4:38:49
this case I'm fine with just saying this user create sign in perfect so let's
4:38:55
give it a go by going right here entering my email. Let's do
4:39:01
javascriptmastery 00gmail.com. The OTP will come to your
4:39:07
email. And once you verify it, you'll be right in. Great job on implementing the
4:39:14
full authentication with all three parts done. Sign out, sign in, and register.
4:39:20
Next, we can focus on uploading some files.
4:39:26
to get started with the file uploader component. You can see it right here on mobile devices in the right sidebar. So,
4:39:32
let's head over to the file uploader component.tsx. Once you're there, let's
4:39:38
install a new package called React Drop Zone, which is a simple React hook to
4:39:44
create an HTML 5 compliant drag and drop zone for files. You know how you can
4:39:50
pull the file and then you can drag and drop it into a website? Well, that's exactly what React Dropzone does. So,
4:39:56
let's copy the installation command and paste it right here. MPM
4:40:02
install--save React-drop zone. And then we can copy its usage. So, let's copy it
4:40:08
and let's paste it right here at the top of the file uploader file. In this case, we're not going to declare the my drop
4:40:15
zone component. So, we can delete it. But instead of that we can copy everything from within it and then put
4:40:21
it within the file uploader component itself right here. So here we have the
4:40:27
onrop as well as some of the special functionalities coming from the use drop
4:40:32
zone hook. And of course since we're using a hook that means that this has to be a use client component or you can use
4:40:40
the wrapper component called drop zone but in this case I'm okay with using it like this. Now, they explain some
4:40:46
additional functionalities, how you can get the files that you input, and more. But I'll explain all of that to you as I
4:40:52
teach you how to use this component. Now, you can see drag and drop some files here or click to select files. And
4:40:58
if you click it, it'll actually open up a file explorer. So, let's first do the UI for the file uploader. So, we know
4:41:05
where we can place our files. To do that, we have this div with a class name
4:41:12
equal to cursor dashpointer. Next, we have the
4:41:17
input. And right below that input, we can render a button. This button will come from
4:41:23
components. It'll have a type is equal to button. And it'll have a class name
4:41:30
equal to CN coming from utils. We're going to always give it a class name of
4:41:38
uploader dashutton and after that we're going to pass it some additional class names
4:41:45
which we can get through props. So right here at the top where we have the file uploader props we can accept the owner
4:41:52
ID which will soon pass. So we know who is uploading the files, the account ID
4:41:57
as well as the class name and we can define the props right here. So that's
4:42:03
going to be interface props is equal to owner ID of a type string, account ID of
4:42:10
a type string and class name of a type string optional. So now we have this
4:42:15
button and within that button we can render an image with a source of forward slassets/icons/upload.svg
4:42:25
SVG with an al tag of upload, a width of about 24, a height of about 24, and I
4:42:35
think that's it. If I save it, you can see how now it has the upload icon, and we can also render a piece of text, a
4:42:43
paragraph that's going to say upload. There we go. Now it's super clear. Below
4:42:49
the button, we can check whether some files exist. And the question is how can
4:42:54
we know where the files are? The files that we're trying to upload. We have to
4:43:00
keep track of them using the state. So right here at the top we can say use
4:43:05
state snippet. Let's call it files set files. And at the start it'll be equal
4:43:12
to an empty array. But in this case we'll specify the type to be a file
4:43:17
array like this. So an array of files. Right now we have some kind of a warning. But don't worry about that. If
4:43:24
we go down right here below the button, we can make a check and see if files.length is greater than zero. In
4:43:32
that case, we can render a ul, which is an unordered list. But let's make sure
4:43:38
to properly close it right here. So file.length is greater than zero. Then we open and close the ul.
4:43:46
That ul will have a class name equal to
4:43:52
uploader-preview-list and within it we can render an h4 that's h4 not h3 with a class name
4:44:01
equal to h4 text-light- and it's going to say
4:44:07
uploading so to know which files are we trying to upload and then below it we
4:44:12
can say files.m mapap and we can map over the files by first getting the file and then
4:44:18
getting the index of that file and then for each one we can basically open up a
4:44:24
new function block and we need to figure out what is the type of that file is it
4:44:29
an image or is it a video so I'll try to dstructure const type as well as the
4:44:37
extension of that file by calling a new function which we can create called get
4:44:43
file type to which We need to pass the file name. Now, this is a function that
4:44:49
we have to create. It's going to be a special function coming from utilities or utils. So, let's head over to
4:44:58
utils.ts. And currently, it's pretty empty. We need to create some kind of a function and export it called get file
4:45:08
type which accepts a string of file name. And then it should return
4:45:15
basically the name. And then it should return the type as well as the extension
4:45:20
of this file. And this is the type of code that I like to use chat GBT or
4:45:26
GitHub copilot for. I'll do something like this. I'll select it. And in this
4:45:31
case, I'll open up a new copilot block. I'll ask it to create a function or
4:45:38
implement the functionality for this function to take in a file name and
4:45:45
return a type and an extension. Let's see what GitHub Copilot
4:45:52
comes up with. Okay, check this out. So, it's getting the extension by splitting the file name by using the separator of
4:45:59
the dot and then popping the first thing. So, it's only going to keep the extension. Then it opens up the type and
4:46:05
it opens up a switch case. If it's one of the most popular image formats like JPEG or PNG or GIF, then it says the
4:46:13
type as image. For MP4 and others, it sets it to video. For MP3 audio, for
4:46:19
PDF, doc, and DOCX document, and so on. Finally, it returns the type and the
4:46:24
extension. This is looking good to me, so I will gladly accept it. And as I said, you can use Chad GPT or any other
4:46:31
AI editor. They're perfect for implementing utility functions such as this one. But just to make sure that you
4:46:37
can 100% follow along, I'll provide you with the complete utils file linked to
4:46:42
the readme of this project's codebase. So simply copy it and override this one right here. You'll notice that it has a
4:46:49
collection of these other utility functions like get file type params. Is it documents? Is it image? Is it media?
4:46:56
or this one that will return the usage summary for each of the categories like the documents, images, and more. Or the
4:47:02
one that we just created that gets the file type based on different extensions and then it just returns that type and
4:47:10
the extension. We do a similar thing for the icons right here. Get file icon.
4:47:16
Based on the extension, we can return a specific asset so we know exactly of which type the file is. With that in
4:47:24
mind, we can now go back here and we can call the get file type
4:47:29
functionality coming from utils to which we pass the file name. And once we get
4:47:34
it, we can return an LI which is a list item with a key equal to a template
4:47:41
string of file.name and then dash index. So this
4:47:47
way we can make it fully unique and we can give it a class name is equal to
4:47:55
uploader-preview dash item. If we do that, we cannot see anything yet because we haven't yet uploaded any files. But
4:48:03
if I type test in there, we should be able to see something for each file that we upload. So back on my desktop, I'll
4:48:10
choose one of the screenshots that I have right here. And we should be able to see something, but not yet. That's
4:48:17
because we're not setting the file to state on drop. We can do that by turning
4:48:22
this callback function into an async function. Specify the type of the accepted files to be a file array like
4:48:31
this. And then within it, we can simply set files and set it equal to accepted
4:48:38
files. If I save this and try to upload it one more
4:48:43
time, you can see that we have this little popup at the bottom that says uploading test. But other than that, not
4:48:49
a lot is happening. So let's continue creating this LI list. Within this LI,
4:48:55
let's create a div. And this div will have a class name equal to flex items
4:49:02
center and a gap of three. And within it, we want to render a special component called thumbnail. So, this
4:49:09
will be a component that will render the preview of the image we're trying to upload. Okay. So, let's actually create
4:49:16
it as a new component in the components folder. I'll call it
4:49:21
thumbnail.tsx. Run rafce. And then I'll go back and import
4:49:27
it right here. Thumbnail. Of course to this thumbnail we have to pass some props such as the
4:49:34
type is equal to type extension is equal to extension and finally the URL is
4:49:40
equal to convert file to URL and then we
4:49:46
pass in the file we're trying to convert. This is another one of the utility functions which takes the URL
4:49:52
object and calls the create object URL of a specific file. So now we can go
4:49:57
into the thumbnail and we can accept those props. We can accept the type, the
4:50:04
extension and the URL which by default can be set to string if nothing else is passed. We can set this over to props
4:50:12
for the type and we can declare the interface props of type string extension
4:50:19
string and URL string. Now we can return a figure. It's a special HTML 5
4:50:24
component typically used for use cases such as thumbnails. Within it, we can render an
4:50:30
image from Nex.js with a source of. Now here we
4:50:36
want to check whether it is an image. So we can do that at the top by saying const is image is equal to and now if
4:50:45
type is triple equal to image then it'll be an image and if extension is not
4:50:53
equal to SVG because SVG is harder to show right here as a thumbnail. So if it
4:50:58
is an image and extension is not SVG then we know that it's an image. So we can say if is image then we simply give
4:51:05
it a URL. else we need to get the file icon which is a function from utils to
4:51:12
which we pass the extension as well as the type and then we are going to pass just a generic image like for video it's
4:51:18
going to be a camera icon for the alt tag we can give it a thumbnail we can
4:51:25
give it a width of about 100 a height about 100 we can give it a class name
4:51:31
equal to let's make it CN for class
4:51:36
names. Let's give it a class name of size of 8 object- contain. And then we can also
4:51:44
give it image class name which is a special prop that we can
4:51:50
pass image class name or just a typical class name if it's not an image. So
4:51:57
class name, we also have to define those two. So image class name will be
4:52:02
optional of a type string and class name optional of a type string. I have to
4:52:07
properly close this image. And finally if it is image we'll also give it the
4:52:13
thumbnail dash image property. Hopefully this makes sense. So
4:52:19
we always give it size 8 object contain. We also pass some additional images from
4:52:25
props if there are any. And then if it is an image we also pass the thumbnail
4:52:30
image class name. In the same way we can style the figure by giving it a class name of CN. And then we can give it a
4:52:38
property of thumbnail and pass all the additional class names if there are any.
4:52:45
So as you can see right now it says uploading and then we have a little thumbnail of the image that I was trying
4:52:50
to upload. This is like an upload model looking good. of course doesn't look as
4:52:56
good on mobile devices, but trust me, we're getting there. Now, below this thumbnail, let's create a div. And that
4:53:03
div will have a class name equal to preview dash
4:53:09
item-name. And it'll simply render the file.name. Let's also render another
4:53:16
image right here. and give it a source equal to
4:53:25
slassets/icons/file-loadader.gif. So this will be the actual loader that we want to show. Let's make sure we're
4:53:31
properly pointing to it. It's assets icons fileloadader.gif. We have to give it a
4:53:37
width of about 80, a height of about 26.
4:53:43
So let's do that. and then I'll tag off loader. If you save it and open it up
4:53:50
and try to upload a file like this screenshot of a YouTube thumbnail, you can see that now this is looking pretty
4:53:57
good. We have the full name and we also have some kind of a loader right here showing the upload process. Let's go two
4:54:04
divs down and let's render one more image which is going to be an image that will allow us to remove that upload. So
4:54:12
let's give it a source of forward slash assets slashicons
4:54:19
slreove.svg with a width of about 24 a height of about 24 an al tag of remove
4:54:28
and on click we can call a function that's
4:54:34
going to take in the event. So it's going to be called handle remove
4:54:40
file and it'll take the event as the first parameter and then the file.name
4:54:46
as the second one. So let's go ahead and create this function right here at the top. const handle remove file takes in
4:54:54
the event specifically react mouse event of HTML image element mouse event and
4:55:01
then the file name which is going to be of a type string that's going to look something like this and then first
4:55:07
things first it needs to stop the propagation so once we click on it we don't want to click anymore below this
4:55:14
model we want to simply stop the propagation we only want to do what this function is doing and then we want set
4:55:20
the files to get the previous files. Okay, because we're modifying the state using the previous state. And whenever
4:55:27
you are doing that, you actually have to have a callback function within the state changer. And in this case, we can
4:55:34
call the prev files dot filter and we want to filter the file where file.name
4:55:42
is not equal to file name. Okay. So, basically what we're doing here is we're
4:55:48
keeping all the other files in the list that we're trying to upload, but we will only remove the one that we click on.
4:55:54
So, if you have multiple, like let's say these two, if you click on one, it deletes that one and then you delete the
4:56:00
other one. Great. Let's also remove this
4:56:05
React right here. And let's just import the mouse event as a type from React.
4:56:11
And I think we need to get the HTML image element as well. So, let's do it. properly event and then within it we
4:56:19
also need to add a comma and specify that this is also a mouse event because even though we're clicking on an image
4:56:25
element this also is a mouse event like this and I will add react mouse event up
4:56:32
front. So let's simply make sure to import react from react. There we go.
4:56:37
This is good now. So now let's head back down. And once you upload files, as you have seen, it's going to say uploading.
4:56:44
And of course, this definitely looks better on desktop devices. And we have some kind of a modal that allows you to
4:56:50
upload files and then see the upload process happen immediately over here.
4:56:55
Now, of course, this is fake uploading it. It's not doing a real upload. And that's because this functionality right
4:57:01
here on simply sets the state which then triggers the loading. but we're not yet
4:57:07
uploading them anywhere. For that, we have to create a new set of server
4:57:12
actions. So, let's head over to lib actions and create a new file called
4:57:22
file.actions.ds. And within it, we can export const our first file action
4:57:28
called upload file, which will take a file of a type file, and it'll open up a
4:57:34
new function block. Let's not forget that this will be an asynchronous function. And let's also make sure to
4:57:41
add the use server directive at the top. So we can ensure that these are only getting called on the server. Alongside
4:57:47
the file, we'll also pass additional things such as owner ID to know who is
4:57:53
creating that file. And actually I won't define the types right here. I'll define them for the entire object. So we first
4:57:59
have to dstructure these props. So we have the file, we have the owner ID, the
4:58:05
account ID and finally the path which we want to use for revalidation and we can
4:58:10
define the type of this to be upload file props. Now what you can do is you can
4:58:17
define an interface of upload file props right here as what we have been doing so
4:58:23
far. What you can also do is create a new file in the root of your application
4:58:29
and call it index.d.ts and then declare this
4:58:35
interface of upload file props right here. That way if you declare it within
4:58:41
this index DTS which some people also like to put within a special folder
4:58:46
which we can call types and then you can drag and drop this index.d.ts
4:58:52
ts within the types it allows you to have global types for your entire
4:58:57
application. So right here you can maybe say that file is of a type file. You can
4:59:03
also say that owner ID will be of a type string account ID string and path
4:59:09
string. Now if you go back you'll see that even if you don't export this
4:59:14
upload file props from this file and if you commandclick you will be able to go
4:59:19
here. So your editor knows this is the right interface. The problem is that sometimes ESLint doesn't know the
4:59:26
TypeScript magic that we're doing with this index DTS. So you still have to export this as an interface and then
4:59:34
import it right here as a regular type. If you do that, ESLint will not complain
4:59:40
and it'll say, hey, just go ahead and use this file. But now I know that it is a string. So this is how we will be
4:59:46
declaring some of the other types in our application, especially some longer ones. And just so we don't have to type
4:59:52
them all by hand, you can find the complete index.d.ds in the readme of this
4:59:57
project. So if you go there, you can paste it and you can copy it here. For example, you can see the upload file
5:00:03
props which we just wrote ourselves is here as well. So now let's continue working on the upload file
5:00:10
functionality. First things first, we have to get access to the storage and databases functionality from apprite. So
5:00:18
let's say const dstructure the storage and databases and that's going to be equal
5:00:25
to await create admin client as we learned so far. We can open up a new try
5:00:33
and catch block that's going to look something like this. In the catch we get an error and we can simply call the
5:00:41
handle error utility function. I think we declared it in our previous actions
5:00:46
file. So that's going to be user.actions.ts. And we can copy the
5:00:51
handle error functionality from here. It is right here. Pretty simple function.
5:00:57
So let's copy it and paste it here. And we're going to pass in the handle error
5:01:03
and a message saying failed to upload files. And now a better question is what
5:01:08
happens within the try block. Well, here we try to read the file. So we can say const input file is equal to input file
5:01:19
dot from buffer and to it we pass the file as well as the file name. This file
5:01:26
is basically a blob that this input file coming from node apprite file
5:01:32
functionality. It's going to read from it and it's going to upload it to their servers. So we can then use that file.
5:01:38
How do we do that? by saying const bucket file is equal to await
5:01:47
storage.create file to which we need to pass the ID of the bucket. So that's going to be
5:01:54
apprite config bucket id. Then we need to pass the id of this
5:02:01
new file we're creating for which you can use the id dot unique functionality.
5:02:07
And finally, we need to pass the file itself, which is the input file. So that's going to end up looking something
5:02:13
like this. We pass the file through props. Then we read it from the buffer
5:02:19
from the blob right here to turn it into an input file. And then we call apprite
5:02:24
storage.create file. We specify the name of the bucket. And bucket simply means where are we going to store this file.
5:02:31
Give it an ID and specify which file are we trying to upload. Then we get the
5:02:36
file within the bucket. Once we have it, we have to be very precise about the information of this file. So let's say
5:02:43
const file document is equal to an object where we first have to specify
5:02:49
the type of that document. It's going to be something like get file type. This is
5:02:58
a utility function we have created before to which we can pass the bucket
5:03:03
file name and then call the type on it. Then we have the name of this file
5:03:11
which is going to be bucket file name. Then we have a URL and here we can use
5:03:19
another utility function called construct file URL to which we can pass
5:03:24
the bucket file dot dollar sign id. Next we need to get the extension which we
5:03:31
can get by using the get file type which is another utility function to which we
5:03:36
have to pass the bucket file. And then call the extension
5:03:41
outside of the parenthesis. Then the size which is going to be the bucket file size
5:03:49
original. Then the owner which is going to be the owner ID. Then the account
5:03:55
ID. Then specify the users that have access to that file which at the start is set to an empty array. And then give
5:04:02
it a bucket file ID which is going to be bucket filed dollar sign
5:04:09
ID. So why are we doing this? We're doing this so that once we store the
5:04:15
file, we actually have access to some metadata about that file. So we can show
5:04:20
an icon by knowing that it's an image or a video. Then we can know how to access
5:04:26
it. We know which extension does it have. We know its name. We know its type. We know its size. All of that
5:04:33
metadata we want attached to that file. So to store the file itself we're using
5:04:39
appite's storage functionality but to store the metadata we'll use app's
5:04:45
databases functionality. So let's say const new file is equal to await
5:04:53
databases dotcreate document. Here we have to say to which database ID we want
5:05:00
to create it. That's going to be apprite config database ID. Then we have to
5:05:05
specify within which collection we want to create it. In this case, it's going to be the files collection. We have to
5:05:12
give it an ID and we have to give it the actual file which we want to store. On this, we can also call a catch with an
5:05:21
async error functionality in case something goes wrong. So that's going to look something like this. Async error of
5:05:28
a type unknown where we can await storage dot
5:05:35
delete file. Uh we have to be very precise with this because if something
5:05:40
goes wrong with creating the database document then that means that we should not store a file in the storage as well.
5:05:47
So we want to delete it. So storage.delete file from which bucket we want to delete it. That's going to be
5:05:53
apprite config.bucket id. And then also which file do we want
5:05:58
to delete? That's going to be bucket file. Dollar sign ID. And we can also
5:06:04
call the handle error. So let's call it right here handle error to which we pass the error and say
5:06:11
fail to create file document. Finally once we finish, if we
5:06:16
finish successfully, we want to call a revalidate path and pass the path. So if
5:06:21
we're uploading from the homepage, we want to revalidate homepage. If we're uploading from documents, we want to
5:06:26
revalidate documents. So we can show the new refresh data. And finally we want to
5:06:32
return parse stringify which is a utility function and to it we want to
5:06:37
pass a new file and this should properly upload our files to appight's databases
5:06:44
and appight's storage solutions. Great. So let's try to use this upload file
5:06:49
server action within the file uploader. So, right after setting the files, I
5:06:55
want to say const upload promises. And I'll explain
5:07:00
exactly why I called it like this. That's because we're uploading multiple files. So, I can say is equal to
5:07:07
accepted files.m map. Not always are we trying to upload multiple files, but if
5:07:14
we are, we want to do it one by one and make sure that all of them fit our requirements. So, we're going to map
5:07:21
over an async function where inside of each one we get access to a file and for each
5:07:28
one we open up a function block. There I have an if statement where I want to
5:07:34
check if files size is greater than max file size coming from constants. We
5:07:41
simply want to set files by getting the access to the previous files because we're modifying the files
5:07:48
based on the current state of the files by saying prev files.filter and filter the one where
5:07:55
f.name is not equal to file.name. Why are we doing this? We're doing it to
5:08:00
clear the files that don't match the max file size criteria or that are bigger than what is allowed. In our case, that
5:08:07
is 50 megbytes. Now still within the if we can go in and return a toast
5:08:14
component. This toast will come right here at the top by saying const toast which we can dstructure is equal to use
5:08:22
toast. And I just noticed that we didn't yet implement toasts. A toast is a
5:08:27
succinct message that is displayed temporarily. It looks something like this. So to implement it, we have to run
5:08:35
mpx chat cnen add latest add toast. So we can do it right here. Let's say y and
5:08:42
let's just press enter for these questions that it's asking us. Next, it wants us to add the toaster component to
5:08:49
the root layout. So let's do just that. I'll head over to root
5:08:55
layout. I'll import it right here at the top toaster. and I'll render it right
5:09:01
here above the ending main tag here. Next, we have to use it by importing the
5:09:06
use toast from hooks use toast. We can do that right here. Then we get access
5:09:13
to the toast. And finally, we can use it like this. So within the if I'll say
5:09:19
return toast and instead of saying scheduled ketchup in this case we can do
5:09:25
something like toast that has a description equal to a p tag with a
5:09:32
class name equal to body dash 2 and text-white within it. We can render a
5:09:38
span with a class name equal to font dash
5:09:44
semibold. So let's end it here. Within that span we can render the file name
5:09:50
and after the span we can say is too large max file size is 50 mgabytes and
5:09:59
we can give it a class name equal to error dash toast. So now
5:10:05
if the file is too large we will simply return this toast saying hey you cannot actually upload that. And we can
5:10:12
actually already test that out. But first, let's remove this drag and drop some files. We don't need that since we
5:10:18
have the upload button. So, I'll go here and remove the text that says upload
5:10:24
files. There we go. That's this one right here. Save it. Now, we have just a
5:10:30
button. I'll click it and I'll choose a video. This is one of the videos for the
5:10:35
ultimate nextGS course that I'm recording at the moment. So, let's try to upload it. It's definitely larger
5:10:42
than 50 megabytes. And it says ask a question. Question form edited is too
5:10:47
large. Max file size is 50 megabytes. But if we try to upload a
5:10:52
screenshot, that actually works like a charm. Great. So now we can continue
5:10:57
with the rest of the setup in case the file is not too large. So right after
5:11:04
this if statement we're going to return the upload file
5:11:10
functionality which is actually a server action which we created to which we need
5:11:15
to pass the file the owner ID the account ID and finally the path which we
5:11:21
want to revalidate and that path is going to come by using the use path
5:11:26
name. So we can say const path is equal to use path name coming from next
5:11:33
navigation and let's appropriately pass it right here by saying path and on this
5:11:39
we can call a dot then so once we get the uploaded
5:11:44
file for each uploaded file we can see if it has been uploaded successfully. So
5:11:51
if is uploaded file then we want to actually remove it from the bottom right
5:11:57
corner where we're showing the file upload process by once again getting the
5:12:02
set files and getting the previous files and then filtering out the file that has
5:12:07
been uploaded. I know we have a lot of these filters but trust me that's how you do it in enterprise applications as
5:12:14
well. Sometimes the code does look a bit clunky. It looks like it's being repeated. It looks like there's a lot of
5:12:20
filters, but that's just the logic that we need to carry out the functionality that we want to achieve. And finally,
5:12:27
why did we call it upload promises? Well, that's because we can have multiple uploads running at the same
5:12:33
time. So, right here where we have the dependencies, we can say that we don't
5:12:39
have to recall this unless the owner ID, the account ID or the path don't change.
5:12:45
These are the dependencies for the use callback that we have at the top. And use callback just make sure that we
5:12:52
don't have to rerun this code every time. Only rerun it if these things change. And now finally right here I
5:13:02
think we need to be within the use callback of the onrop. We can say await
5:13:07
promise.all upload promises. So we want to await the upload process of all the
5:13:13
files. In this case, we don't need to get access to this is drag active from use drop
5:13:19
zone. And I actually think we're good. I actually think that this will now implement the upload functionality. We
5:13:26
have all the necessary checks. We're removing the files from the list. If we click on the X. So, let's give it a
5:13:32
shot. I'll try to upload a screenshot. This one right here of a thumbnail of
5:13:38
our ReactJS crash course. It says uploading. And we get an error. That's
5:13:43
good. At least something happened. We have coded a lot of stuff. So it's normal that an error happens. In this
5:13:49
case, it says invalid document structure missing required attribute bucket field.
5:13:55
And this is happening on line 45 of file actions DS. So if I head over to file
5:14:02
actions DS, line 45, it points to where we're trying to create a new document.
5:14:08
We're using a weight. So let's just make sure that this is an asynchronous function. And it is and specifically it
5:14:14
is saying missing required attribute bucket field. So let me hover over the
5:14:20
create document. It looks like it accepts the database ID, the collection ID, the document ID, and then the data.
5:14:28
But I don't see the mentions of a bucket field under create document. Buckets are
5:14:34
typically mentioned under create file right here. But maybe we're looking at
5:14:39
it the other way around. Maybe the error is not within our code because here it
5:14:45
says bucket file ID but our error is saying that we're missing bucket field
5:14:51
which is something entirely different and that makes me think that we might have made an error right here within our
5:14:57
apprite project where we were setting up the database structure specifically the
5:15:03
structure of our files. So if we head here and go to attributes, you can see
5:15:08
that I called it a bucket field and made it required. But actually it should be a
5:15:13
bucket file ID. So let's update this.
5:15:18
Reload the page and let's try to re-upload another file. In this case, I'll upload a screenshot of the error
5:15:25
we've been having just to reminisce of it once we actually fix it. It says uploading and we get another error
5:15:31
saying account ID is now missing. That's also happening here and we're passing it
5:15:38
to the upload file as one of the props. Let's see if that's being passed properly from the file uploader. If we
5:15:45
go here, we can see that where we're calling the upload file, we are passing the account ID which is of a type
5:15:51
string. So this makes me think that we're passing it properly. And are we passing it to the file uploader? That is
5:15:58
another question. So let's head over to where we're calling the file uploader.
5:16:03
that's going to be within our header, I believe. So, let's head over into the header component. And as you can see,
5:16:10
we're not passing the necessary props that will make the file uploader work. So, let's first do that. And
5:16:17
that's going to be the last step needed to make this work. We need to pass the owner ID and the account ID. But you can
5:16:24
see that even our header doesn't have access to those. So, let's head over to the root
5:16:29
layout and let's pass the necessary props to the header component. I got to
5:16:35
say we are doing just a bit of prop drilling right here because we're going too level deep with passing props, but I
5:16:42
will still consider this to be fine in this case. So, let's pass the user ID equal to current
5:16:49
user dollar sign ID. And let's also pass the account ID equal to current
5:16:55
user dot account ID. Now we can head over to the header
5:17:01
and we can accept those two new props. That's going to be a user ID as well as
5:17:08
an account ID and those two will be of a type. User
5:17:14
ID is of a type string and account ID is of a type string as well. And now we can
5:17:22
pass them over to the file uploader by saying owner ID. So who owns this file
5:17:28
that's going to be equal to the user ID. And we have the account ID which is going to be equal to the account ID. And
5:17:35
I know that we're calling the file uploader from one another file. I think it's going to be mobile navigation. So
5:17:41
right here we also have to pass the necessary props. But in this case, our mobile navigation I do think already has
5:17:48
access to the owner ID and the account ID. Let's see if that is the case where we're calling it right here. We're
5:17:54
spreading all the information about the current user. So in that case, we won't have the user ID, but we will have the
5:18:01
current user dollar sign ID for the owner ID. So I can dstructure the dollar
5:18:07
sign ID and account ID is as it is. But in this case, we can rename the dollar
5:18:13
ID to owner ID. It's going to make it a bit easier to refer to later on. And we need to define it right here within the
5:18:20
props. Now, let's pass them over to our file uploader. That's going to be owner
5:18:26
ID equal to owner ID and account ID equal to account ID. If we do that,
5:18:34
we're good. Our file uploader is getting all the necessary props. And in this case, I have to thank apprite because we
5:18:40
made the field required. So it let us know that we're not actually passing all the necessary fields. But now we can try
5:18:47
to upload this one more time. It says uploading and it actually disappeared
5:18:53
very quickly though, which made me think that it actually uploaded the file to the database. So, if I head back over to
5:19:00
AppRight, go to databases, files, and then documents, we can see a new
5:19:05
document has been added with a name of screenshot, a URL where it has been
5:19:10
uploaded to a storage bucket with a type of image, a bucket file ID, account ID,
5:19:16
owner, which is a relationship to the user, the extension of PNG, the size, and everything else.
5:19:24
And if you head over to storage file storage, you can see a single screenshot
5:19:30
that has been added. And it's actually this error screenshot that thankfully has been resolved. But you can see that
5:19:37
we actually have a URL that allows us to access it. So that means that our file upload functionality has now been
5:19:44
completed. And just for good measure, let's also see if it works from the mobile menu. So, if I head over here and
5:19:50
click upload, I'll try to upload some other screenshot. And it looks like it went
5:19:56
through. Great. Now, it's possible that if you try to upload a bit of a larger file, it didn't work for you, even
5:20:03
though the maximum size is 50 megabytes. That's because NexGS payload by default
5:20:09
has only 4 megabytes limit. So we can close all the currently open files and
5:20:15
we can head over to next configt DS and we need to add a new object right here
5:20:21
called experimental. Open it up and we need to set the server actions
5:20:27
specifically the body size limit to let's do something like 100 megabytes
5:20:33
just to make sure that we're not blocked by Nex.js. So now both of our limits
5:20:39
apps is set to 50 for free projects and Nex.js's is set to 100. So we should be
5:20:44
good. Next we'll have to render all of these different pages such as documents, images, media, others, and more. That
5:20:51
will allow us to fetch the files we just uploaded and then show them on the screen. That's the whole point of this
5:20:56
application anyway, right? To be able to upload, store, and then retrieve the
5:21:02
files. But feel free to take a bit of a pause now because this lesson has been a long
5:21:07
one. The functionality for implementing the upload has been well let's say
5:21:12
detailed with this file uploader component and then even the upload file actions haven't been super simple to
5:21:18
make. We had to mess with the storage and database create a new file and then also create a new document in the
5:21:25
database to store all of that files as metadata. While we're here, I just noticed that we have one issue regarding
5:21:31
the upload file props coming from types. Let's see why is that. In this case,
5:21:37
we're importing this. As I said, typically when you declare interfaces, you don't even have to import them. But
5:21:44
then, even though our TypeScript knows how to find this interface because it is declared as a TypeScript interface, you
5:21:51
can see that ESLint is simply not okay with that. So what we could do is
5:21:56
suppress this no undefined line so that even eslint is fine with it. And this is
5:22:02
actually a good solution. What you can do is you can suppress this eslint warning for the entire file by copying
5:22:10
this no undef heading over to
5:22:15
eslint.rc.json going after the extends and adding the rules functionality. And
5:22:20
within the rules, you can say no
5:22:29
undef. So if you go back, we're good. Typescript knows what it is. Everybody's
5:22:34
happy. Great. With that said, we have successfully implemented the file upload
5:22:40
functionality. Next, let's focus on adding the routing for these different pages so we can actually show the files
5:22:47
that we have created. to start implementing dynamic routing to
5:22:53
render different routes for different file types. Let's head over to our file explorer. Go within the app folder and
5:23:01
let's create a new dynamic route within the root folder. I'll call it new and
5:23:08
let's open up the dynamic segment which you can do with an opening and closing square bracket. And let's call it type.
5:23:15
And within this dynamic type path, we can render a new
5:23:21
page.tsx. Within it, run rafce. And we're just returning page right here.
5:23:26
Now, a better question is, how can we extract the exact type of the page we're on? Right now, if I head over to
5:23:34
documents, you can see that it simply says page. Still, if I go to images, it still says page even though the URL
5:23:41
changes. So let's do that by extracting it from params. We can dstructure the
5:23:46
params at the top and say that it is equal to search param props. Then we can
5:23:52
say const type is equal to now in new versions of Nex.js you have to await
5:23:58
params. So let's say await params and then question mark. We can also add as string right
5:24:06
here. So our typescript is not complaining. And since we're using a weight, we have to turn this function
5:24:12
into an asynchronous function. That's going to look something like this. And
5:24:17
if we don't have a type, by default, it can be an empty string. So now, instead of rendering just a page, let's render a
5:24:24
div with a class name equal to
5:24:29
page-container. Within it, let's render a new section that'll have a class name
5:24:36
equal to w-ool. And within it, we can render an H1 with a class name equal to H1 and
5:24:47
capitalize. And here, let's render the type. So now, check this out. Documents
5:24:53
basically says documents. Dashboard still is different because that's just the home route. It has to be different
5:25:00
from all of the other type routes. But images, media, others, we can switch between them immediately. Now we can see
5:25:08
the powers of the left side sidebar. How the active class changes based on the URL and the page changes as well. In
5:25:14
simple words, we have just created a dynamic route. And a dynamic route is
5:25:20
where the path changes based on the URL instead of being static. This is handy
5:25:25
when you want to create multiple pages that follow the same structure. Like in our case where we have the same
5:25:30
structure for video, audio, others, images, and so on. At least the layout is the same.
5:25:37
But in our case, the file type document, video, audio, others actually changes
5:25:43
and displays some different kind of data. So now let's continue developing it. Right below the H1, I want to render
5:25:50
a div that'll have a class name equal to total size section. And within it, we
5:25:58
want to render a P tag with a class name equal to body-1. And right within it, we can say
5:26:06
total and then render a span with a class name equal to H5. That's going to
5:26:13
simply render the total size. But of course, this total size has to come from
5:26:19
somewhere. We have to somehow fetch it. So for now, I'll simply say 0 megbytes.
5:26:25
Let's fix this class name and let's save it. There we go. Total 0 megabytes.
5:26:31
Right below that we can create a new div which we'll use for sorting. So here we
5:26:37
can give it a class name equal to sort-ash container and within it we can render a
5:26:44
p tag with a class name equal to
5:26:49
body-1 and typically hidden but on small devices block and text- light 200 within
5:26:58
which we can say sort by and then below it we can render a new sorting
5:27:04
component. So let's create a new component within the components folder and let's call it
5:27:12
sort.tsx runce and then imported right here where
5:27:18
it says sort coming from components. If you now save this, you
5:27:24
can see a little sort by sort right here. But very soon we'll turn this sort into an actual sort that allows you to
5:27:30
sort by name, file size, type, and more. But for now, let's actually display our
5:27:36
types because it doesn't make any sense to sort them if we cannot even see them. So for that reason, let's go below this
5:27:44
section and let's try to dynamically render the files. To do that, we first need to know
5:27:52
which files are we trying to fetch. In other words, we have to write a query
5:27:57
that will allow us to fetch the files. So let's head over to file actions and
5:28:03
below the upload file we can now create a new one export const get
5:28:10
files which is equal to an async function and we can get started creating it within it we can get access to
5:28:17
appight's databases functionality by saying cons databases is equal to await
5:28:23
create admin client like so and then we can open up a try and catch
5:28:29
block within the catch we get the error and in case something goes wrong we just
5:28:35
handle that error like a boss. So let's just pass over the error and say fail to get files. Within it we can form the
5:28:43
query to get the files not all the files but rather files based on many different
5:28:48
criteria. One of which and maybe the most important of which is the user that is currently logged in. So we only need
5:28:55
to show the files that they have access to. So we can say const current
5:29:01
user is equal to await get current user
5:29:06
and below that we can check if there is no current user. So if no current user
5:29:12
then we simply throw a new error saying something like user not
5:29:18
found. Now that we have the user, let's form all the different queries to query
5:29:23
our files by saying const queries is equal to a call of the create queries
5:29:31
function to which we can pass the current user. So let's create this new helper function called create queries.
5:29:39
We can do it right here at the top. const create queries that accepts in a
5:29:44
current user and then starts forming the queries which is basically equal to an
5:29:51
array of multiple different apprite queries such as
5:29:56
query coming from apprite or and then within it a query.equal
5:30:05
equal where the owner property is equal to an array of current
5:30:11
user dollar sign ID and then we can duplicate this and check whether the
5:30:18
current ID is within the users array of a specific file that would also be okay
5:30:24
or in this case it would be their email not the user ID because the access to that file has been shared with them so
5:30:31
that's also a completely valid way in which we want to get access to a specific file. Now that we have those
5:30:37
queries, we can simply return the queries and later on we can
5:30:43
further extend them by looking at search, sort, limits and more. But for
5:30:49
now I'm fine with just having those queries and the current user will be of a type
5:30:55
models document. This models of course coming from apprite. So you can import
5:31:01
it from node app. And now we get access to those queries right here. So let's actually make a call to the database. We
5:31:08
can do that by saying const files is equal to await
5:31:14
databases.list documents. We first have to tell it from which database we want to list documents from and that's going
5:31:21
to be apprite config. database id. Next we have to tell it from which
5:31:27
collection. In this case it's going to be from the files collection. And finally, we pass in all the queries that
5:31:33
we want to use to query the files. And here I need to say list documents. There
5:31:38
we go. Let's properly close it. And we're going to simply return parse
5:31:44
stringify the files that we have gathered. Now let's head back over to the page and let's try to make a call to
5:31:50
this server action by saying const files is equal to await get
5:31:57
files which is coming from lib file actions and to it we can pass our
5:32:04
current user. So let's put it in an object if we're dstructuring it. Just call it like this. It doesn't need any
5:32:10
parameters for now. and then try using it right here below by saying if
5:32:15
files.length length is greater than zero, then render a
5:32:22
section. Else render a p tag saying no files
5:32:29
uploaded that's going to have a class name of empty dash list. And if you do
5:32:35
that, we get an error saying invalid query cannot query equal on attribute users because it is an array. So if I
5:32:42
head back to file actions and if we look into the queries that we wrote, you'll notice that for the users, we have to
5:32:48
say contains and not equal because two arrays can never be the same. So if we
5:32:54
switch this over to contains, you can now see no files uploaded for documents.
5:32:59
Same thing for media and others. But what about images? It also says no files
5:33:04
uploaded. That's not good because we know that we have uploaded some images before. So let's quickly check our query
5:33:10
where we're fetching the files and let's console log different parts that go into the list documents such as console log
5:33:18
the current user and let's also console log the queries that we have and finally
5:33:24
let's console log the files themselves by saying console log
5:33:30
files. Now if we save it and reload the page and open up the terminal let's see
5:33:36
what do we have here. We get back the current user and its account ID as well
5:33:42
as the dollar sign ID. I think we're using specifically the account ID right here in the query. Yep, current user
5:33:50
dollar sign ID. Here it is. And current user email. Let's see if we have that.
5:33:56
Yep, we have that too. Next, let's see whether we have access to the queries. Yep, queries look good to me. method is
5:34:02
or with the values equal to the owner ID or if it contains our email address. And
5:34:08
finally, we get back two files which are counted as documents. Oh yeah, that is
5:34:13
true. The files are actually within the documents array. So if I head back, this is not going to be files.length. It's
5:34:20
going to be files.total is greater than zero. And if you do that, the no files will disappear, which means that we can
5:34:26
try to render some of the files right here. So let's actually render a class name on this section equal to file list
5:34:34
and within it let's map over files dod documents dom where we get each
5:34:39
individual file of a type models document and for each document we can
5:34:45
return an h1 with a class name equal to h1 and let's make it simply render the
5:34:54
file dot I think it has a title if I'm not mistaken taken. Let's see if that is
5:34:59
the case. Oh, we got a warning that we need to have a key prop. That's right. So, each H1 has to have a key equal to
5:35:07
filed dollar sign ID. There we go. And it might not be title. Let's see what do
5:35:13
we have under a file. Let's try to render its ID for now. The dollar sign ID. At least we know that has to be
5:35:20
there. And take a look at this. For images, we have one and it appears to be two. And for all these types, we have
5:35:27
two right now because we're doing the same fetch for all of them. So it doesn't matter on which page we're on,
5:35:33
at least not right now. But later on, based on the page URL, we can change this. So let's try to render the
5:35:40
file.name. And you can see that we have two different screenshots. This is perfect. It means that we're
5:35:46
successfully fetching the documents from the database. Of course, it would be much better if we could actually show
5:35:52
that as a nice card, give a preview of a thumbnail, and allow the user to see this image. This on its own is not super
5:36:00
useful. So, let's create a new component called
5:36:06
card.tsx runce and let's import it here instead
5:36:11
of this h1. So, that's going to be now a card component. Make sure to give it a
5:36:16
key equal to filed dollar sign id and then pass a prop file is equal to file.
5:36:23
So now within this card we can access all of the properties related to each file so we can create a proper file
5:36:30
card. Let's dstructure those properties just to be where we were. Each file is of a type file models document. Make
5:36:39
sure that the models is coming from apprite. And now we can render a file.name name for each file. There we
5:36:46
go. We have two different screenshots. But now, let's turn this into this. Much
5:36:51
more beautiful cards for each different type of a file. It can be a video, it can be audio, it can be an image, and so
5:36:58
much more. So, let's do that in the next lesson. to start creating our file card. Let's
5:37:05
turn this div into a link because each file will actually be clickable and it
5:37:11
can lead you to the details or open up the modal for that card. Of course, a link has to have an href. And in this
5:37:18
case, it'll be equal to file URL. And we're going to also give it a target
5:37:23
equal to underscore blank so it opens up in a new screen and doesn't close our existing window. We can also give it a
5:37:31
class name equal to file-ashcard. There we go. Now it looks more like a card.
5:37:36
Right within that link, let's render a div. And that div will have a class name
5:37:42
equal to flex and justify dash between. Right within it, we can render a
5:37:47
thumbnail component which we created not that long ago. It needs a type equal to
5:37:53
file.type as well as the extension equal to file.extension. and we can close it
5:37:59
right here. You can notice that we'll get some errors and some broken images. So to fix it, let's also give it a URL
5:38:06
equal to file URL. Let's give it a class name equal to
5:38:11
exclamation mark size 20. That's to make it important to make sure that our classes are getting applied. And let's
5:38:18
give it an image class name equal to important size 11.
5:38:24
If we do that, it'll make them a bit bigger and it'll make the errors go away. But now, why is this image not
5:38:30
actually showing? It is saying the current user is not authorized to perform the current action. That happens
5:38:35
if I click on it. But if I reload, yep, the images don't seem to be showing, and that's because we're getting a 401 from
5:38:42
AppRight Cloud. We can look into fixing that later. But for now, let's deal with the rest of the card. I'll go right here
5:38:48
below the thumbnail and create another div that'll have a class name equal to
5:38:53
flex flex- call items- end and justify dash
5:38:59
between within this one. Later on, we'll have the actions drop-down component
5:39:05
which will show some kind of a drop-down that gives us additional actions that we can perform on this file such as rename
5:39:12
it and do all kinds of other stuff. But for now, let's simply keep it as a piece of text. Below it, let's add a P tag
5:39:20
that'll have a class name equal to
5:39:26
body-1 and it'll call convert file size and we can pass to it the file size.
5:39:33
This way, instead of getting a large number, we're getting something that looks a bit more reasonable. Like a
5:39:38
typical file size would be huge number in bytes. But here we pass it the bytes
5:39:43
and then we get a reasonable number in kilobytes, megabytes or gigabytes. Now we can go two divs down and then create
5:39:51
another div right below it that's going to have a class name equal to file-card
5:39:56
dash details. Within it, we can have a p tag within which we can render the file
5:40:02
name. So let me actually use this name right here within the p tag. and I'll give it a class name equal to subtitle-
5:40:11
2 line-clamp-1. This ensures that it doesn't take more than a single line.
5:40:18
After that, we can go below the p tag and render a new component called formatted date time. It'll be a
5:40:26
self-closing component. So, let's go ahead and create it within the components folder and call it
5:40:32
formatted date time.t tsx run
5:40:39
rafce and then simply import it right here. It's going to simply say formatted
5:40:44
date and time and to it you want to pass a prop of date which is going to be file dot
5:40:52
dollar sign created at as well as some additional class names like class name
5:40:58
is equal to body-2 and text- light- and now we can accept those props
5:41:05
within the formatted date and time it's going to be date and class name of a
5:41:12
type date is a string and class name will be optional also of a type string
5:41:20
and what this will be is a simple P tag that'll call the format date time and
5:41:26
pass in the date and we can give it a class name equal to CN which stands for
5:41:33
class names body-1 and text- light-200
5:41:38
always and then sometimes also apply by the additional class names that come
5:41:44
through props. That's going to look something like this. So now we can see 5th of November, 8:56 a.m. 8:58 a.m.
5:41:52
right here. Great. So that is our formatted date and time. And below it,
5:41:58
we can have another P tag that'll say by and then render the
5:42:05
file.name. And we can further style it by giving it a class name of
5:42:11
caption line-clamp-1 and text-
5:42:16
light- 200. Now it's a little smaller right here, but it still looks good. So
5:42:22
besides this image not actually showing, we have successfully completed this card
5:42:27
UI. And it's not only that the image is not showing. If you click on it, that's supposed to open the image. But we get a
5:42:35
401, which means unauthorized. And this means that the fix could only be in one
5:42:40
place. And that is within the app rights dashboard. If you go to the project, head over to storage file storage
5:42:48
settings, and then right here, go to permissions, add an any RO, and turn on
5:42:55
all the permissions for that role, and click update. Another cool thing about
5:43:00
apprite file storage is that it allows you to have a certain file security
5:43:05
enabled so that users can access it only if they have access to bucket permissions. You can configure whether
5:43:12
or not the files inside the bucket should be scanned by the apprite anti virus and you can also choose a
5:43:18
compression algorithm. There's a lot of stuff that you can do such as choosing allowed file extension. Basically
5:43:23
letting us know that choosing apprite for the file storage application was the correct choice. So going back now that
5:43:30
we have reestablished our permissions. We can reload and take a look at this.
5:43:35
We can see the thumbnails right here. And if you click on it, we can see the full image. Of course, I should have
5:43:40
used some better looking images, but the most important thing right now is that we can actually see the images, see the
5:43:47
files that we uploaded, and even access them within their full definition online. As you can see, the URL is
5:43:53
pointing to cloud.apprite.io v1 storagebucket and then to the ID of that file. Great. So,
5:44:01
that means that we're almost done with this file card, but now we have to implement the actions dropdown.
5:44:08
That's this thing right here. So, let's go ahead and create a new component for the action dropdown. I'll call it action
5:44:18
dropdown.tsx. Run rafce. And then I'll import it right here instead of this piece of text. That's just action
5:44:26
dropdown. And it's going to be a self-closing component to which we can pass the file equal to file.
5:44:34
So let's head into that action dropdown and let's go ahead and implement it together in the next
5:44:42
lesson. Let's implement our action dropdown. It should look something like this. Once you click on it, it should
5:44:49
open up some kind of a combination between the shaden dialogue and a drop-down menu component. So let's
5:44:56
implement it by heading over to chaten and specifically I'll go over to the
5:45:01
dialogue component. Yep. This dialogue right here, I believe
5:45:06
we have already installed it. So, we can just go ahead and copy all the imports that we'll need. And then we can copy
5:45:13
its usage right here. I'll paste it in the action dropdown. Oh, it looks like
5:45:18
we haven't actually installed it. So, let's go ahead and do that by copying this command and running mpx chats add
5:45:27
latest add dialogue and press enter to install it. And the second component we
5:45:32
need is a drop-down menu. So search for drop-down menu. It looks like this. So
5:45:39
go ahead and install it by running mpx chaten at latest add
5:45:46
drop-down dash menu and then simply copy its
5:45:52
imports as well as its usage right here. We can put it right here instead of all
5:45:58
of this content from the dialogue. We simply need a dialogue and then within it we'll immediately display a drop-own
5:46:05
menu. So we can remove all the other imports from the dialogue. And now if I head back and click open, this is what
5:46:11
we get. So let's define some use states. In this case, we'll have a use state
5:46:18
equal to is modal open. Set is modal open at the start equal to false. And
5:46:25
we'll also have another use state snippet called is dropdown open and set
5:46:31
is dropdown open which will at the start be set to false as well. Of course if we want to use the use state we have to
5:46:38
turn this into a client component which it definitely is. There we go. Now let's
5:46:43
give this dialogue a open property equal to is modal open as well as the onopen
5:46:50
change equal to set is modal open. For the drop-down menu let's give it the
5:46:57
open property equal to is drop-down open. And for the onopen
5:47:03
change let's actually give it set is dropdown open. Next, we have the drop-own menu trigger, which is going to
5:47:11
have a class name equal to
5:47:16
shad-now-focus. And within it, we can render a next.js image tag with a source
5:47:22
of forward slash assets/icons/Ots.svg
5:47:27
SVG with an alt tag of dots, a width of
5:47:33
about 34, and a height of 34. There we go. So now this is looking
5:47:39
closer to the design. Now let's focus on what happens after we click it, which is
5:47:45
the drop-down menu content. We first have the drop-own menu label which will have a class name equal to
5:47:53
max-W200 pixels and truncate in case the name is too long
5:48:00
and within it we can render the file name. Of course we have to get access to
5:48:05
the file through the props. So let's dstructure the file that we passed over
5:48:10
and this file will be of a type file is models.doccument. document models coming
5:48:17
from node apprite. So now we can see the file. Next we want to render a separator
5:48:24
and then we want to render a couple of different menu items. And for that we actually want to map over
5:48:32
actions drop-down items map where we get
5:48:37
each individual action item. And for each one, we automatically return a
5:48:43
drop-down menu item that has a key equal to action item value. And for now, it
5:48:50
can just render the action item label. So we immediately got rename,
5:48:57
details, share, download, and delete, which will be all of the different actions that we will support from within
5:49:03
our application. Now, where are these actions coming from? Well, if you hold control or command and click on them,
5:49:09
it'll lead you to our constants where you can see that this is simply an array of different objects that have a label,
5:49:17
icon, and a value. And we just list different functionalities, which I simply copied from the design right
5:49:23
here. Now, let's go ahead and style it so it looks better. First things first, each one of these drop-down menu items
5:49:31
will have a class name equal to shad-ashdropown item and it'll have an
5:49:39
on click property. So once we click it, we want to choose which action we have
5:49:44
selected. So for that reason, we want to go here and create a new use state
5:49:50
snippet for the chosen action. I'll call it action set action at the start set to
5:49:58
null. And we can say that this action will be of a type action type coming from
5:50:06
index.d.ts or null because at the start it is set to null. And now we can scroll down and on click we can set action to
5:50:14
be equal to action item just like so. We can also make a check and see if an
5:50:23
array of rename or share or delete or
5:50:31
details do includes the action item do value. Then we're going to set is modal
5:50:38
to open. That's going to look something like this. Why is that? That's because
5:50:43
if we choose anything from here, we want to show a new model that's going to allow us to perform additional actions
5:50:49
that we specified. Like rename opens up a rename modal. Details opens up a
5:50:54
details model. Delete opens up a modal that allows you to confirm your
5:51:00
deletion. Same thing for share. It opens up a modal to ask you with which people you want to share it with. And the only
5:51:06
thing that doesn't open up a new model is download as it automatically downloads it. So that's why we're doing
5:51:12
this here. And it looks like I didn't properly close this array right here. I have to close it here. There we go.
5:51:18
That's better. And then what do we actually show for each action item? It's not just a label, is it? Well, we want
5:51:25
to make it into a link with an href of
5:51:30
construct download URL to which we can pass the
5:51:35
filebucket file ID. And this construct download URL is coming from utils. It'll
5:51:43
simply point to our apprite endpoint and then construct the URL that contains
5:51:48
this file by finding it in the files array. And then it'll also point to forward/d download and pass the
5:51:55
necessary project. So it knows exactly where that file is stored. We can also give this link a download property equal
5:52:02
to file.name name and a class name property equal to flex items center and
5:52:09
a gap of two. Now we cannot see anything just yet. But within this link we can render
5:52:16
an image. This image will render different icons for each one of these types of
5:52:23
actions. So that's going to be action item do icon. All tag will be equal to
5:52:29
action item label. It'll have a width of about 30 and a height of about 30. And
5:52:37
we can save it. Oh, it looks like action item is not defined. So, we have to properly spell
5:52:44
it. And now we can see those different icons which match our application's theme perfectly. But of course, next to
5:52:50
the image, let's also render the action item that label. There we go. This is looking great. But now we'll only show
5:52:58
this link if we're trying to download something because then we navigate to the download link, right? Else we don't
5:53:04
want to make it a link. So what I will do is I will add a new check right here
5:53:10
and check if action item value is triple equal to download. In that case I will
5:53:18
show this link. else we can render a div that'll have
5:53:23
the same class names as the link and it'll actually render the same thing that is within the link which is the
5:53:29
image and the label but it simply won't be a link it'll be just a simple div. So
5:53:35
now everything is looking the same but if you click download it'll actually immediately download the image and you
5:53:41
can see that it works wonderfully. There we go. That's great. But all the other links won't do
5:53:48
anything for now because what they have to do is open up a new model. And that
5:53:53
model looks something like this. I mean, if you check this out, this is the model for sharing. And we have a model for
5:54:00
renaming as well as moving to trash and so much more. We'll make it super reusable. So,
5:54:07
let's actually focus on implementing that dialogue or that modal that'll show up. We have a dialogue here, but then
5:54:14
within it, we're showing the menu. So sometimes we need to show this dialogue content in form of a modal and we can do
5:54:21
that by saying const render dialogue
5:54:26
content is equal to an arrow function that looks like this and then it can
5:54:32
return some kind of a dialogue content. So we can say dialogue content coming from components UI
5:54:39
dialogue and then we can say dialogue. Now, when will we render this dialog
5:54:44
content and where we're going to render it? At the bottom of this dialogue we created right here where we have the
5:54:51
drop-down menu. Right below it, we'll call the render dialogue content as a
5:55:00
function. Immediately, we'll get some errors. Let's see what they're saying. They're saying that a dialogue content
5:55:06
requires a dialogue title. Okay, that's not a problem. Let's just head over to
5:55:11
Shatzien, search for dialogue, and copy everything from within the dialogue content. That's going to look something
5:55:17
like this. It has the content, the header, the title, description, and all that good stuff. And of course, we need
5:55:24
to get the imports for the dialogue as well. Now that we're actually putting it to practice. So, let me copy it right
5:55:32
here and paste it. Now if we go back and click and click
5:55:37
rename, you can see that a new model shows up. But now is our turn to style
5:55:43
it properly. So let's give this dialogue content a class name equal to shad
5:55:49
dialogue and button. That's much better. Let's give
5:55:54
the dialogue header a class name of flex flex- call and a gap of three. Let's
5:56:02
give the dialogue title a class name of text- center hint text-
5:56:09
light- needs to render a label specifically an action label. So
5:56:16
what we can do is say if there is no action we're going to simply return null
5:56:22
nothing. But if there is an active action we can simply dstructure the
5:56:27
value and the label from that action. So we don't have to say action label every
5:56:33
time. We can simply render the label. There we go. Now the label says rename.
5:56:39
We don't need a dialogue description in this case. But below the title we want to make different checks for different
5:56:46
types of actions. So if a value is triple equal to rename in that case we
5:56:52
want to render an input field that looks something like this coming from
5:56:58
components UI input. It'll have a type of text and a
5:57:03
value equal to. And now the question is where are we going to get the value from? Well, we're going to keep it all
5:57:10
in the state. So right here at the top we can create a new use state snippet and call it name which is going to mean
5:57:16
file name at the start equal to file name because we already have the file
5:57:22
name but we might want to modify it. So now if we head down we can pass the
5:57:28
value equal to name. If you save that and click rename
5:57:33
you can see that the value is already populated exactly what we want. Now we also have to somehow keep track of the
5:57:40
change in that name. So we can say onchange is equal to we get an event and
5:57:46
then we call the set name with e.target value. So now if you decide to change it
5:57:52
you can freely change it like this new file name. Of course we need to be able
5:57:59
to submit that somehow. So let's go below the dialogue header. Let's create
5:58:04
an array and say if an option is rename, delete or
5:58:11
share. If any one of these three are included, so that includes the value of
5:58:16
the current action, then let's render a dialogue footer as well. This dialogue
5:58:23
footer will have a class name equal to flex flex- call a gap of three and on
5:58:31
medium devices a flex of row because we don't have enough space to show it in a
5:58:36
column and within it of course we'll render a button a submit button as well
5:58:43
as a cancel button. So this first one can be a cancel and the second
5:58:48
one will be a submit. Within the submit, I'll render a P tag with a class name of
5:58:55
capitalize and there I will render the value which simply means the action
5:59:00
we're trying to perform like rename. Also next to that we have to know whether we're currently loading. So I'll
5:59:06
create a new use state and I'll call it is loading. Set is loading at the start
5:59:14
set to false. And then I can say if is loading
5:59:20
then render an image that's going to have a source of
5:59:25
assets icons loader. SVG with an al tag of
5:59:32
loader a width of about 24 a height of about 24 and a class name of animate
5:59:41
dash spin. And we can close it. There we go.
5:59:46
That's looking good. I'll reload the page. There we go. Let's now give functionalities to these buttons. I'll
5:59:53
create two new functions. One will be called const close all modals which is
6:00:01
going to be equal to a function. It simply sets everything to false. Set is
6:00:06
modal open false. Set is dropdown open false. Set
6:00:12
action. We want to reset the action that was selected. So set it to null. Set
6:00:18
name back to the original file.name. And later on here, we also want to reset the
6:00:24
set emails that we're trying to share this account with in case the user
6:00:29
didn't proceed with the sharing. This will be if we cancel the action. But if we don't cancel it, then we want to
6:00:36
handle it. So we can create a new handle async function called handle actions.
6:00:42
And we can call these on their appropriate buttons. So on the cancel button, we
6:00:48
want to give it an on click equal to close all modals with a class name of
6:00:56
modal dash cancel. If we save it now, even if we
6:01:02
change something and I click cancel, it closes it and the changes didn't take effect. Great. Now let's do the opposite
6:01:09
with the second button by giving it an on click equal to handle actions or no that should have been action singular
6:01:16
because it can only do one at a time. So handle action and we can also give it a class
6:01:24
name equal to modal-submit dashutton. There we go. This is looking
6:01:32
good. So now we have a fully functional model that allows us to perform different actions or at least it
6:01:39
properly showcases the action for the rename at the time being. So now that we have the UI to make this functionality
6:01:46
work, let's implement the logic for the rename file functionality. Let's do it
6:01:51
together in the next lesson. To implement the rename
6:01:56
functionality, let's go back to our code and let's head over to file.actions.ts.
6:02:02
ts. We can scroll down and we can create a new function by saying const rename
6:02:09
file is equal to an async function that accepts a couple of props which we're
6:02:15
going to dstructure such as the file ID, the name of the file, the extension and
6:02:22
the path to regenerate. All of these types are going to be of a type
6:02:27
rename file props and we can open up a function block. Now we have to implement
6:02:33
it. To start implementing it, let's open up a function block. Let's get access to
6:02:38
the databases coming from apprite which is equal to create admin client. Let's open
6:02:45
up a try block as well as a catch block. And within the catch we can handle the
6:02:51
error by saying fail to rename the file. But within the try we can try to form a
6:02:57
new name. So const new name is equal to a template string of
6:03:05
name.extension and then we simply get the updated file by saying is equal to
6:03:11
await databases.update document. So in this case we're updating the metadata stored
6:03:17
in the database. and not the file within the storage. That's because we're handling files metadata within the
6:03:24
database. So now we have to choose the database ID, then the collection ID,
6:03:30
then the file ID which we want to update and finally provide the data which we want to update. We want to update the
6:03:36
name to the new name and after that we want to revalidate the path to point to
6:03:43
this new path and return parse stringify the updated
6:03:49
file. Now we can export this rename file and we can use it within our actions
6:03:56
dropdown. If we head over to this handle action, we can first check if there is no
6:04:03
action, then we simply want to return not do anything. If we start doing
6:04:08
anything, that means that we must start with the loading. I'm going to set the success status equal to false at the
6:04:15
start, but we can change it later on. And then I want to create an object of
6:04:20
all the different actions and the corresponding functionalities attached to those actions such as a rename
6:04:28
action. On rename we want to call a callback function that calls this rename
6:04:34
file function to which we need to pass the file ID name extension and
6:04:40
everything else. So let's say file ID is equal to filed dollar sign ID. Then the name
6:04:51
is equal to name. Extension is equal to file.extension. And we pass in the path.
6:04:59
That's going to look something like this. The path in this case has to come from use path of course. So let's say
6:05:06
const path is equal to use path name coming from next navigation. There we
6:05:13
go. And now we're handling the action of a rename. Of course for share it's going
6:05:19
to be an entirely different callback function that'll do a different thing. Same thing for delete. But for now let's
6:05:26
focus on rename. So we can modify the success status based on the return of
6:05:32
the action. Bear with me. This will be a bit more complicated. We want to
6:05:39
await actions and then we want to access a specific action value. Meaning if it's
6:05:46
rename, then we want to just call the rename functionality. So we'll just call it
6:05:53
like this. Finally, if we have a success, then we want to close all
6:06:00
modals and set is loading to false. Now, let's put the
6:06:08
success as a let variable because we're modifying it right here. And let's also define the types right here saying that
6:06:14
action value will be as key off type actions. This way it knows that it
6:06:22
can be only one of these three things rename, share or delete. And then we can
6:06:28
call actions dot rename, share or delete. In this case, we're calling
6:06:34
rename. So now if we go back to the browser and try to rename this error
6:06:39
screenshot, we can do that by saying rename. Let's call it error
6:06:45
screenshot. And click rename. And it should call that server action. And you
6:06:51
can see that it successfully renamed it. That's great. The second one is a screenshot of the ReactJS full course.
6:06:58
So let's simply rename it to React full
6:07:03
course. And that's it. Our rename functionality now works. Now in a very
6:07:10
similar manner we'll implement all the other functionalities like view details which
6:07:16
is going to be even simpler or maybe move to trash like this or even the
6:07:22
toughest one which is going to be the share where we'll be able to choose which users we want to share it with
6:07:28
based on the email. So next, let's focus on this one right here, which is view
6:07:34
file details, such as the file size, the owner, the last edit, and the
6:07:42
format. To start implementing file details, head over to the components folder and create a new file called
6:07:49
actions modal content.tsx and run rafce. We're going
6:07:57
to use this actions model content to create some helper components to display
6:08:03
things within our action dropdown. So right within here, we won't have just a single default export called actions
6:08:10
model content. Instead, we'll have multiple smaller exports that are going to help us form the UI in the action
6:08:17
dropdown. We can call the first one file details like this and export const file
6:08:24
details. These file details will accept the actual file which is going to be of a
6:08:29
type file is models.doccument models coming from node
6:08:35
apprite. Now we can head back over to the action dropdown. Head down to render dialogue content. And so far we have
6:08:42
covered the case where the value is equal to rename. But in this case we want to make a check and see if value is
6:08:50
equal to details. And if it is we want to render a self-closing file details
6:08:57
component like this to which we can provide a file is equal to file. Now,
6:09:04
back within documents, if we head over and click details, you'll be able to see file details. So, let me collapse the
6:09:11
browser and head over into the file details component. Within here, we can
6:09:16
first create an additional helper component const image
6:09:21
thumbnail, which is going to be a component for displaying file information. So, let's pass it the file
6:09:28
equal to file modules.cument document and it can have an immediate return meaning just parenthesis where it'll
6:09:35
return a div with a class name equal to file-details- thumbnail if we spell
6:09:42
class name properly and now we want to use it within the file details so right
6:09:47
here I'm going to use a an empty react fragment and within it I will display
6:09:54
image thumbnail to which I will pass the file which is equal to file
6:10:00
Now I'll collapse this just so we can see the browser as well. And you can see what soon will become the image
6:10:07
thumbnail. So let's actually render the thumbnail by rendering the thumbnail component which we created not that long
6:10:14
ago to which we have to pass the file type. We also have to pass the
6:10:19
file.extension. And finally we have to provide the URL equal to file URL. And
6:10:26
we can close it right here. If you do that, we can see a little thumbnail of the file. Below it, let's render a div
6:10:35
that'll have a class name equal to flex- call and flex. And within it, I'll
6:10:43
render a p tag that'll render a file. We can style it a bit by giving it
6:10:49
a class name equal to subtitle- two and margin bottom of one. And below it, I
6:10:58
want to render a formatted date and time to which we're going to pass a file dot
6:11:03
dollar sign created at property and a class name equal to
6:11:11
caption. If I save this, you can now see a little timestamp appearing right here.
6:11:17
And that's going to be it for our image thumbnail. But now we can continue adding more file details. So let's
6:11:23
create an additional helper component called detail row. const detail row is
6:11:30
equal to a component that accepts a label and a value for that label. We can
6:11:35
define those with different types. Label of a type string and the value of a type string. And we can have an immediate
6:11:43
return. We're going to return a div with a class name is equal to flex a
6:11:49
paragraph within which we will render the label and it'll have a class name equal to
6:11:56
file-details- label and I'll duplicate it below change this to value and then
6:12:02
change the actual value of label to value. If I save this we can now use
6:12:08
this detail row. if I fix the spelling right here, right here within our file
6:12:16
details. So let's do just that. I'll call a single details row as a
6:12:23
self-closing component to which I'll pass the label equal to format and then
6:12:29
a colon and a value equal to file.extension. If we save it, you can
6:12:35
now see format.png. If I duplicate it one, two, three more times. We can also provide a size equal
6:12:44
to file dot but of course we have to wrap it in convert file size and then
6:12:50
call file.s size. There we go. The next one will be owner. So who is the owner
6:12:56
of the file? That's going to be file.ame. And finally we can do
6:13:03
something like last edit which is going to be file dollar sign updated
6:13:10
at there we go and we can also wrap this in format date and
6:13:15
time it's this function right here to which we will pass the file updated at.
6:13:23
Of course this format date and time has to be imported. So if we do that properly and
6:13:29
if we head over to details you can see format PNG size owner and last edit we
6:13:36
can compare it with the design and it looks like it's quite similar but the text is left aligned. So I have to left
6:13:43
align these values which we can do by wrapping these detail rows in a
6:13:49
div and putting them all together and giving this div a class
6:13:55
name equal to space-y-4 padding x of two and padding
6:14:02
top of two as well. This will at least give it some spacing. But to fully align
6:14:07
it, we can give those two P tags a text dash left property, which will align it
6:14:13
on the left. And now this is looking much better. This is looking great to me. So right below the details action,
6:14:20
we now want to deal with the share functionality. Yep, share is coming next. And it is one of the most exciting
6:14:27
features of our application because it'll allow us to share the files with other accounts. So let's do that next.
6:14:36
To implement the share functionality, let's add a new check right here and see
6:14:42
if the value is equal to share. If that is the case, we can render a new
6:14:48
component. Let's call it share input. Of course, this is a new component that we
6:14:54
haven't created yet. So, let's head over to the components folder and create a new share input.tsx.
6:15:02
run ref inside of there and let's simply import it right here. Once you have it,
6:15:10
this share input will have to know which file do we want to share. So let's pass
6:15:15
over the file. Let's also create a new use state at the top and let's call it
6:15:23
emails and set emails at the start equal to an empty array. This is going to be
6:15:28
an array of emails with which we want to share the file. And let's also create another function right here. I'll call
6:15:36
it const handle remove user. And that's going to be a function that will remove
6:15:43
the users from the sharing functionality if needed. So now let's pass those props
6:15:49
over to this component right here. So if value is equal to share and that's going
6:15:55
to go below the details then we can pass it over the oninput
6:16:00
change which can be equal to set emails and in the same way we can also
6:16:07
pass the on remove equal to handle remove user and I just noticed that I
6:16:12
messed up the value check for the details it should have been triple equal sign so only if it is details then we
6:16:20
show that model still works, but now we can work on the share. There we go. So
6:16:27
now let's head over into the share input. Let's implement the UI and then we can focus on implementing the
6:16:33
functionality. We already know which three props we want to get. We want to have the file, the oninput change and on
6:16:41
remove and these will be of an interface called props. So let's define the props
6:16:46
right here by saying interface props and it's going to have a
6:16:52
file equal to models document. It'll also have an
6:16:58
oninput change which is going to be a react.dispatch. Specifically it'll be a
6:17:05
dispatch of react set state action which is going to set an array of
6:17:12
strings that's going to look like this. And finally we have the on remove which
6:17:17
is going to accept an email which we want to remove of a type string and it'll return void meaning nothing. Now
6:17:25
right within this share input we can actually use an image thumbnail which we created in the action model content.
6:17:33
This one right here. So I want to make sure to use it. So you know what if we
6:17:39
kept the details right here we can also keep the share input here as well.
6:17:44
So let me actually copy this part the interface and the share input
6:17:50
declaration and then I will actually remove the share input file
6:17:55
itself. And I'll put it within the actions modal content right here below
6:18:02
the file details. And of course we'll have to fix the import within the actions dropdown.
6:18:08
So let's head over to actions dropdown and let's fix the import. It's
6:18:14
going to come from actions modal content of course only after we actually export
6:18:21
it by saying export const share input. Great. So now let's use this image
6:18:28
thumbnail which we have created just above. That's going to be image thumbnail, not the image, but rather
6:18:35
image thumbnail, which is going to accept a file equal to file. That's going to look something like this. And
6:18:42
let's make sure that it's actually taking account of the changes. If I head down and see where we have the share,
6:18:49
it's pointing to the right one. I'll reload the page as well. Go over here to share. And now we
6:18:57
can see the image thumbnail. This is great. So we know what we are sharing. Now right below it we can create a new
6:19:04
div with a class name equal to share dash
6:19:10
wrapper. And within it we can create a new p tag that's going to say share file
6:19:16
with other users. And of course we can style it further by giving it a class
6:19:22
name equal to subtitle- two padding left of one and text- light of 100. Next
6:19:31
right below it I'll render an input. This input will come from components UI
6:19:37
input and to it we can pass a type which is equal to email a placeholder equal to
6:19:46
enter email address on change we can handle that
6:19:52
event by saying oninput change and then we can use the e.target target dot
6:19:59
value. But in this case, I will trim it and I will also split it based on commas
6:20:06
because sometimes maybe somebody wants to add multiple emails right within a single
6:20:12
input. Finally, I'll give it a class name equal to share dashinput dash
6:20:19
field. Okay, that's looking better. Right below it, let's create another div
6:20:25
and give it a class name equal to padding top of
6:20:30
four. Another div within it with a class name of flex and justify dash
6:20:38
between. And within it, we can render a P tag that'll have a class name equal to
6:20:47
subtitle-2 and text- light- that's going to say share width.
6:20:54
And then below it, we can duplicate that P tag. And then here we can say file do
6:21:01
users.length users. So instead of saying share with users, I'm going to say shared width. And then here I'm going to
6:21:08
show the number of users. And we can change this text light 200 to denote it
6:21:14
like this. Right below it, we want to map over the different users. So let's
6:21:20
create a new ul an unordered list. Below the
6:21:25
div, it'll have a class name equal to padding top of two. And here we can say
6:21:33
file do users do map. And then for each user email, we can automatically return
6:21:40
an LI, which is a list item. For each list item, we can give it a key equal to
6:21:48
email because they'll be unique with a class name of flex items- center justify
6:21:56
between and a gap of two in between the elements within the list item. Then we
6:22:02
can render a P tag with a class name of subtitle-2. And here we can display in
6:22:10
the email address. So now if we try to share it, I don't think we'll have anything there just yet because we
6:22:17
cannot share it because we haven't yet implemented the share functionality, but that'll be there soon. Below the P tag,
6:22:24
we can present a button which will allow a person to remove the user from
6:22:29
sharing. So let's give it an on click which is going to call a callback
6:22:35
function and we're going to call the on remove functionality to which we can pass the email. This email is of a type
6:22:44
string right here. And within the button let's not just say remove. Let's actually render
6:22:51
an icon. So that's going to be an image that's going to have a source of assets
6:22:57
icons remove. SVG with an al tag of
6:23:03
remove. We can also give it a width of about 24, a height of 24, and a class
6:23:10
name of remove dash icon. So now later on once we have the
6:23:16
users here, you'll actually be able to remove them by tapping an X next to their email.
6:23:22
But of course, now we actually have to implement the functionality to share the
6:23:28
file with users whose emails we enter in here. First, we have a TypeScript error
6:23:34
right here within our set state. That's because we haven't specified the type of this state. And we're going to say that
6:23:41
it's going to be an array of strings and then we should be good.
6:23:47
So now let's actually implement the functionality to share our file. We can
6:23:52
do that by heading over to file.actions.ts. And we're going to copy
6:23:58
the entire rename file like this. And I'm going to paste
6:24:05
it right below. But this time I will change the name to update file users.
6:24:13
We're going to accept the file ID. This time we don't need the name, but rather we need the emails we're going to update
6:24:20
it with. And we can get the path. And I'm going to change this over
6:24:26
to update file users props. We once again get access to the database. But
6:24:33
instead of trying to form the new name, we don't have to do that. We're simply trying to update the file by calling the
6:24:40
databases.update update document to which we pass the database ID so we know
6:24:46
the file within which database to update. Then we let it know within which collection to update it and finally the
6:24:52
file ID and then instead of changing the name we want to change over the property
6:24:58
of users and make it equal to emails of those users. That's going to look something
6:25:05
like this. Finally, we revalidate path and pass over the updated file. So now,
6:25:13
if we head over back, we now have access to that server action. We also don't
6:25:19
need this dialogue description, so I can remove it. And what's going to happen is
6:25:25
we're going to go here where we have the functionality for share. Remember, we already mapped all of our actions to
6:25:32
specific actions that a user performs. So if the user is trying to press this button share, we want to call this new
6:25:38
function we created. So here we can call the update file users. We're going to
6:25:45
pass in an object containing file ID equal to filed dollar sign ID. That's
6:25:52
going to look something like this. We want to pass over the emails. And we also want to pass over the path. So it's
6:25:59
going to look something like this. So, what do you say that we give it a shot? I'll enter my second email. I think I'm
6:26:06
logged in with contactjmastery.pro. I'll share it with javascriptmastery
6:26:13
00gmail.com. It says share. And it looks like something has happened. And there
6:26:20
we go. Shared with JavaScript mastery 00. There seems to be some kind of a
6:26:25
problem with this image right here. But other than that, the file seems to have
6:26:31
been shared. Let's just see what is the issue with this content right here. So if I head over to share input, go down.
6:26:39
We have this assets icons remove. Let's just give this button a class name equal
6:26:45
to share- dash user. So it looks less like a button and more like an actual icon,
6:26:53
of course. Now to truly test this out, we have to log in with the email that we shared the file with. So let's give it a
6:27:01
go. Oh, it looks like there's a problem. I shared the file with myself. So that's
6:27:07
actually very good because now that makes us implement the remove share functionality which we haven't done
6:27:14
yet. It is right here in action dropdown and it's called handle remove user. To
6:27:20
remove it, we just have to make it into an async function that accepts the email
6:27:26
we're trying to remove of a type string. And then we have to form the new updated
6:27:32
emails array equal to emails.filter where we get each
6:27:37
individual email. And we just check whether that email is not equal to the
6:27:42
email that we're trying to remove. Once we do that, we can say const success is
6:27:49
equal to await update file users which is the server action we created. We're
6:27:56
going to pass it the file ID the emails equal to updated emails and the path and
6:28:02
if we have a success. So if success in that case we simply set the emails equal
6:28:09
to updated emails and let's not forget to close all modals. So let's give it a
6:28:16
shot. I'll go here and remove it. And there we go. Looks like the user
6:28:22
has been removed. Now let me actually share it with my second account by clicking
6:28:31
share. There we go. I will log out so we can one more time see this great looking
6:28:37
signin functionality. I'll sign up with Adrian second and I'll use my other
6:28:45
email. Let's give it a go. There we go. An enter OTP appears. I'll just paste it
6:28:52
in and click submit. Immediately we are in. It
6:28:58
doesn't yet appear on our homepage, but if we head over to documents, you can see the file right here, and you can see
6:29:05
it is created by AdrianJS Mastery. This is looking great to me. All of the other
6:29:10
information about the file as well as the ability to view a file and even
6:29:16
downloaded is allowed to me within my second account. Even though I never had to do anything with it, another user
6:29:23
just shared it with me, which I think is one of the most important functionalities from Google Drive,
6:29:29
Dropbox, or any other file storage solution, allowing you to share your file with others. And in this case,
6:29:36
since you have access to it, you can even share it with other people. A great exercise for you would be to implement
6:29:41
some admin privileges. So now that the file has been shared with you, you cannot actually remove the admin that
6:29:47
created it. I actually wanted to leave this in as an additional functionality that you can
6:29:52
implement. But with that said, the next part we can focus on is what happens after the share and that's going to be
6:30:01
the delete functionality. Download share details and rename have been implemented. The delete functionality is
6:30:08
the only one that remains. to implement the delete file
6:30:13
functionality. We can check for the value of the action equal to delete in which case we can trigger a delete
6:30:20
modal. So let's say delete and if that is the case we can then render just a
6:30:26
single p tag that's going to have a class name equal to delete dash
6:30:31
confirmation and we can say something like are you sure you want to
6:30:37
delete and then we can leave an empty space like this. After that, we can render a span that's going to have a
6:30:44
class name equal to delete-file dash name. And within it, we
6:30:51
can render the file.name. And then we can put the question mark at the end. If we now try
6:30:58
doing that by going over here and saying delete, you can see this. Are you sure you want to delete error
6:31:04
screenshot.png? And we can then choose cancel or delete. And of course to implement the delete option we actually
6:31:11
have to create a new fileaction which will once again be very
6:31:16
similar to the previous ones. So we can copy the update file users. We can paste
6:31:23
it below. We can rename it to delete
6:31:29
file. We need to get the file ID which we want to delete. We need to get the
6:31:34
bucket file ID as well. So we know where it's stored in the memory and then we
6:31:40
need to get the path and this will be of a type delete file props. Now that we
6:31:46
have that we need to get access to the databases but also the storage. So right
6:31:51
here we have to say storage is equal to await create admin client. First we
6:31:57
delete it from the database and that means deleting the metadata of the file. So we can say deleted file is equal to
6:32:05
await databases.delete document in this case
6:32:10
we delete it from the database with this ID from this collection and then this file in this case we don't have to pass
6:32:16
a fourth parameter because we only want to delete it after that if we delete it from the
6:32:24
database. So if deleted file exists in that case we also want to delete it from
6:32:30
the storage by saying await storage.delete file and we want to
6:32:37
delete the file from the upright bucket ID and we want to delete the file with
6:32:42
the bucket file ID. If we do that, we can revalidate the path and finally send
6:32:48
over a object that has a status of success.
6:32:55
So if we give that a go, we can actually import the delete file right here under
6:33:01
our set of different actions where we have the delete and we can call the
6:33:06
delete file to which we can pass an object of the file ID equal to filed
6:33:14
dollar id. We can also pass the path. But let's not forget to pass the bucket
6:33:20
file ID equal to file.bucket bucket file ID because this time we actually have to
6:33:26
delete it from the storage as well. So if we do that, let's try to
6:33:32
delete this error screenshot. I'll go over and delete it and click delete. It seems like nothing
6:33:40
has happened. That's because delete seems to be unused in this case. At least it says that it is an unused
6:33:46
property even though we're using the actions and then action value of key off
6:33:52
type of off actions. So we are actually accessing the delete property right here
6:33:58
which should be of a type promise of any. Let me reload the page here. Oh and
6:34:03
looks like the file got deleted. So let me actually log out and let me log into
6:34:08
my second account. So that's going to be the contactjmastery.pro Pro where we have another
6:34:16
file. And let's log in. Let's head over to images. And it looks like we have no
6:34:23
files over here. What about documents? Yep, no files here either. Interesting.
6:34:29
Let's try to add a few more files. But actually, I'll take some time
6:34:35
to find some good images to upload them, some good media as well, and maybe even
6:34:40
some documents. So, I'll pause the video. You can go ahead and find some of your files or you can find some online
6:34:46
as well and then we can upload them together just so we have more files over here. I'll head over to Unsplash for
6:34:51
some images. Let's go ahead and take this nice looking interior. I'll quickly
6:34:57
download it. Let's also find some more like this wall right here. Oh, maybe this dog as well. There's also this
6:35:04
great site called Cover where you can find some great video footage which is completely free. Oh, it looks like they
6:35:11
have music as well, but let's go with videos for now. And let's download any one that is below 50 megabytes. Most of
6:35:18
these should be, I believe. Yep, there we go. 2 megabytes. I'll go ahead and
6:35:24
download it. Let's get this coffee as well. Full HD. Just so we have some stuff to work
6:35:30
with within our storage application. There we go. This one is cool as well.
6:35:36
And you know what? Let's do music as well. I think I saw that they offer music. So, if I head over here at the
6:35:43
top, I'll click music and I'll download any ones from here, just a couple. I'll
6:35:49
get all of them in standard quality. And finally, we need some PDFs. And what
6:35:55
better place to find some PDFs than under some of these YouTube videos. There's a great PDF guide for the Nex.js
6:36:02
GS crash course which is actually a huge 200 and something page long ebook which
6:36:08
you can download but I think that's a bit too large to upload it to our platform. So let's maybe go with
6:36:13
something like this Git and GitHub guide which you can download by going to resources and then you can simply enter
6:36:19
your name and email and you can get it in your email immediately. There we go.
6:36:26
Here it is. So let me download it and press download at the top. I believe now
6:36:31
we have one of each. We have images, media, storage, and others. So, let's go over to upload. I'll head over to my
6:36:38
downloads, and I will try to upload all of these at once. Let's see if that actually works. This is a real test for
6:36:45
our application. I'll click open. And check this out. It's uploading all of
6:36:52
them at once. It even has the thumbnails for images. It has a video icon for videos. It has a music icon for music.
6:36:59
And we even got one alert saying that the next year's ebook was too good to be uploaded. Just kidding. It was too
6:37:06
large. But as you can see, we had real-time alerts about all of these files. And now if you head over to
6:37:13
documents, we can see all of them right here. If you head over to images, we can also see all of them. Media has all of
6:37:20
them. And that's another issue, right? Because currently we're fetching all the files. But what we need to do is we need
6:37:26
to sort them based on their type. So, on media, we should only be showing media. On images, we should only be showing
6:37:32
images and so on. But damn, is it so good to be able to see a full library of
6:37:38
files just like this. And I mean, check this out. If you want to open up this MP3, you just click it and the music
6:37:45
just started playing. If you want to open up a PDF guide, check this out. It immediately opened it up within my
6:37:51
browser. Or maybe you want to open up an image. Well, that works, too. And of
6:37:57
course, we can perform all of these different actions on every single one of these files. Let's try to actually
6:38:03
remove one of these songs. I'll go with this discover preview right here to see
6:38:08
if the delete functionality works. So, are you sure you want to delete discover preview? I'll click
6:38:15
delete. And there we go. It was deleted immediately. Great work. Now, we know
6:38:21
the deletion is working. And the next thing we'll do is we'll fix up our get
6:38:27
files. I think that's how we called it. Let's see where it is. There we go. Get files. So that it can actually sort and
6:38:35
filter files based on their type. Let's do that
6:38:41
next. To fetch the files based on the file type, we first have to head over to
6:38:46
the dynamic type page. And notice that right now we're just extracting the type
6:38:52
from the params, but we're not actually sharing it anywhere. If you see this
6:38:58
type variable is completely unused besides being right here in the title.
6:39:03
So let's use this type and let's pass it over as a prop inside of an object to our get
6:39:10
files. Next, we can get into the get files functionality and we can accept
6:39:15
the type right here by dstructuring it, getting the types and making it equal to
6:39:22
an array. So, this is one important differentiation that I want to make is that here we're just passing the type,
6:39:29
but instead of that, let's do types. Okay? Because sometimes we might want to show multiple types. So, how are we
6:39:36
going to filter it properly? Well, I created a quick utility function that will help us do just that. We can say
6:39:42
const types is equal to get
6:39:48
file type params and to it we can pass the type and we can say as file type
6:39:58
array like this. If you look into the get file type params you'll notice that for documents it returns an array of
6:40:04
documents. For images it's images. For other it is other. But for media it
6:40:10
includes both the video and audio. So now we can simply say types and then
6:40:15
make it equal to types like this. Let's head back over into get files. And let's
6:40:21
give it a prop type of get files props like this. And now we can use those
6:40:28
types to properly fetch the data. Right here where we're calling the create queries to that we can pass the second
6:40:36
parameter of types and now in the create queries functionality we can accept
6:40:41
those types right here as the second parameter which is going to be equal to an array of strings like this and we can
6:40:49
form an additional query based on the types. So I'll say if types.length
6:40:55
length is greater than zero. In that case, we want to push an additional queries by saying
6:41:03
queries.push query equal and we want to make it equal if a
6:41:09
type is equal to the types that we are sharing over right here. So that's it. We have just added
6:41:17
the type filtering by adding an additional query into the create queries
6:41:23
and we're now fetching the files based on that additional query right here. So let's save it. Let me reload
6:41:31
the page and check this out. Now we have only images. If we head over to
6:41:37
documents, we have a document. In media, we have both the video and audio. and in
6:41:44
others we don't have anything yet right now. So this is looking great and this was pretty simple but actually this was
6:41:51
just a first step into implementing our search. Yep, types will be connected
6:41:57
with search as well. Why? Because we will do it all through this single file
6:42:04
action. And you might be wondering how. Well, that's because we'll use search
6:42:09
params to manage the URL query. Once we search something, we will append an
6:42:14
additional question mark right here and then say something like query is equal to let's take this small white dog
6:42:22
example by saying query is equal to small. Okay. And when I go here, we'll
6:42:28
want to access this query and then based on it filter the data. We can do that by
6:42:35
extracting the search params right here from props by saying search
6:42:40
params and then we can say const search text is equal to we want to await search
6:42:49
params and then question mark dot query and I want to say that this is as string
6:42:57
or it'll be an empty string at the start. Let's properly close this right here. And we can duplicate this search
6:43:03
text with sort as well because later on we'll also be adding sorts to this. So
6:43:09
we can say query small and then we can say and sort is latest for example. So
6:43:16
now we can extract those values such as search text and sort and we can pass
6:43:21
them as additional parameters to the get files functionality. So alongside types,
6:43:27
let's pass the search text and let's also pass the sort. So now I can head
6:43:33
over to get files and I'll expand this just so we can see the search query right here at the top. There we go.
6:43:39
Let's accept those additional parameters right here by getting the search text which at the start can be set to an
6:43:47
empty string if we don't have any other value. For the sort, we're going to give it a default value of dollar sign
6:43:54
created at -ashdeesc, which stands for descending
6:44:00
and limit as well in case we want to limit to a couple of files per page. Now
6:44:07
that we have all of those props, we can actually pass it into form queries. So
6:44:12
I'll pass it right here. After types, I'll pass the search text. After that,
6:44:17
I'll pass the sort. And finally, I'll pass the limit. Now, let's head into the create queries. And in the same way that
6:44:24
we have pushed this additional query for the type, we can duplicate it two more times. And if we have search text, so if
6:44:34
search text exists, which of course we have to get through props. So let's get it right here. Search text of a type
6:44:41
string. Then we have sort of a type string. And finally, we have an optional
6:44:47
limit of a type number. There we go. That's better. So,
6:44:53
if we have search text, then we push query dot contains since we're searching
6:44:58
for text name contains the search text.
6:45:04
What does that mean? Well, that means that we're comparing this small white dog photo with the query coming from
6:45:11
here. And you can see it actually queried it. If I search for something like I think we had red in the other
6:45:16
title. There we go. White house, red roof. That works. And if I search for white, it should actually show both the
6:45:23
dog and the house, which means that search works properly. And let's also add an additional query by limit. So if
6:45:31
a limit exists, then queries.push query.limmit. And we can simply pass the
6:45:37
limit right into it. So we can limit to a specific number of photos or files per
6:45:43
page. We can also apply sorts by saying const sort const and then dstructure the array
6:45:51
of sort by and order by and make that equal to
6:45:58
sort.split. Okay. Why are we splitting the sort? Well, that's because the sort
6:46:04
will contain both the sort and the order in which we want to sort it. For example, we saw an example of that sort
6:46:11
right here where we use the default for the get file. Where is it? Oh, here it
6:46:18
is. Created ad and then the actual order. So, we want to sort it by the
6:46:23
order of creation in a descending order. Once we get each one of these sorts, we
6:46:30
can use the queries push. If order by is equal to ascending
6:46:37
asc, then we can return a query order as
6:46:42
c based on the sort by and else we can return a query
6:46:49
order and based on the sort by. So that can be sorted by title or name or maybe
6:46:56
created at or whatever else. Oh, after I change the sort, it looks like something has happened. It says attribute not
6:47:04
found in schema white referring to list documents right here. Interesting. Let
6:47:09
me try to remove the sort from here. And still the same thing happens. If we open up the terminal, we can see it says
6:47:16
invalid query attribute not found in schema white. Interesting. Let's see why this
6:47:23
might be. Let me check the order of parameters we're passing into create
6:47:28
queries. We have current user types and then after that we have search sort
6:47:34
limit. Okay, is that the same thing we're passing into it? Let's see. Search
6:47:41
sort limit. Yep, this is looking good to me. We first generate the queries and
6:47:46
then based on different if statements, we push additional queries into it. Now it's referring to white. So it's
6:47:53
referring to the query which is equal to white in this case. Specifically search text is currently set to white. So we're
6:48:01
simply pushing the query where the query contains specifically the variable of
6:48:06
attribute name contains the search text of white. I don't see why that would be
6:48:11
a problem. And this only started happening after we added the sorts. If I remove the sorts, you can see that it
6:48:18
works and we can say white dog and white house. So what actually broke it with these queries right here. Well, first
6:48:25
let's check whether we have a sort. So if sort exists, then we can do those
6:48:30
additional things right here. If sort doesn't exist, let's not do anything with it. If there is no sort, it should
6:48:37
be set to created at descending. Let's try to console log the queries to see if
6:48:43
that gives us any more information. So I'll say console log queries. I'll reload the page and then scroll up. And
6:48:52
there we go. Here are the queries. You can see that we have a contains query
6:48:58
for the name of white, which is great. But then we have a method of order
6:49:04
descending with the attribute of white. Interesting. Why is it picking the name
6:49:10
or in this case the search text when it comes to the sorts? Oh, I see why. I
6:49:16
copied this and I forgot to change this sort right here to sort. Oh, that's my
6:49:22
bad. Okay, as soon as I fixed it, the error is gone. And now I think we should
6:49:27
be able to actually sort it as well. We'll test that later on once we implement the sort toggle. But in any
6:49:33
case, we're good. And now we have complete functionality for sorting based on type as well as based on search. But
6:49:42
of course, our users are not going to really search through files through the URL bar. We want to implement this
6:49:48
global search functionality right at the top. So, let's close all of the currently opened files. And let's head
6:49:55
over to search.tsx, which is a component that we created before and completely left
6:50:02
alone. Now, we want to come back to it and implement it. Let's go to this size
6:50:07
right here so we can see it. And let's bring it to life. To implement the search, let's start with the UI. But for
6:50:14
that to work, I'll move the browser to the left side because the search is right here to the left and I'll move the
6:50:20
code editor to the right. This should be more than enough space. Oh, I actually like it this way. Now, let's give this
6:50:27
div a class name equal to search. And within it, let's create a new div that's
6:50:34
going to have a class name equal to search
6:50:40
dashinput-wrapper. Right within that div, we can create an image, which will
6:50:45
just be a search icon. So, let's give it a source of forward
6:50:51
slashassets/icons slash search.svg. Let's also give it an al tag
6:50:58
of search with a width of 24 and a height of 24 as well. That's just going
6:51:05
to be a little search icon. But now we have to add an actual input coming from
6:51:10
components UI input. And we have to create a new use state to manage it. So
6:51:16
let's create a new use state. Call it query and set query at the start equal
6:51:23
to an empty string. Since we're using use states, we have to turn this component into a use client component.
6:51:31
Just like this. And now we can pass it over to our input as a
6:51:36
value. Value is equal to query. Placeholder is equal to search dot dot
6:51:44
dot. Class name is equal to search dashinput.
6:51:50
And on change we can call the event and then call the set query based on the
6:51:57
event.target value. So now we can actually type into it. But of course the changes are not yet happening. And in
6:52:04
this case we actually want to do something special. We want to implement a global search which will search across
6:52:11
all the files no matter on which page we're on. Even if we're in documents, it
6:52:16
would be super simple to just query the documents, right? based on the name, but this will act as the global search. So,
6:52:23
it'll show us all the files no matter where we're at. So, now that we can
6:52:28
actually modify the state of the query through a search, let's actually implement the functionality that'll
6:52:35
fetch the files. I'll create a new use effect. Of course, the use effect has a callback function and a dependency
6:52:42
array. If left empty, this effect will only happen once at the start of the
6:52:47
load of this component. And in this case, I want to check if a search query
6:52:53
exists. What search query are we talking about? Well, that's going to be the one
6:52:58
coming from params. So, this is going to be a bit different than fetching the search query right here from the type
6:53:05
here. We're just dstructuring it and then saying await search params.query. But if we're in a client
6:53:12
component, the process is a bit different. Here you can get it through the use search params hook. So let's say
6:53:21
const search params is equal to use search params
6:53:29
coming from next navigation. And then we can get the search string by saying const search string or we can call it
6:53:37
search query is equal to search params.get
6:53:44
get query or it can be set to an empty
6:53:49
string if there is nothing there. So now we can say if a search query doesn't
6:53:54
exist then simply set query our current state query to an empty string as well
6:54:02
and this will change whenever the search query changes. This is just the first
6:54:07
step. If there's nothing there, reset the input. But now let's create another
6:54:13
use effect. And within this one, we want to fetch the files by saying const fetch
6:54:18
files is equal to an asynchronous function. We can call it right here by
6:54:24
saying fetch files. And how can we fetch the files? By saying const files is
6:54:30
equal to await get files. So this is the same server action we called before. And
6:54:37
to it we can pass everything else. We can pass the search text equal to query.
6:54:44
Finally, once we get the files, we want to actually set them to the state. So we can say use state. Let's call it
6:54:51
results. Set results at the start equal to an empty array. And the type of this
6:54:58
will be models dot document and specifically an array of model
6:55:04
documents. And once we have the results, we also want to open up a new model to
6:55:10
show those results. So we can open up a new use state snippet. And let's call it open set open
6:55:18
at the start equal to false. So now that we get the files right here, we can say set
6:55:26
results is equal to files.cuments and we can set open to be
6:55:33
set to true. Okay, let's give it a shot. I'll create
6:55:39
a new piece of UI right here where I want to check if open is set to true. In
6:55:45
that case, I want to create a ul, an unordered list with a class name of
6:55:51
search dash result within which I will say results. Let's see if that works.
6:55:58
The results immediately appear here. That's good. But is there something in there? Well, let's find out. We can do
6:56:06
that by saying results.length is greater than zero. If it is, then we'll return the
6:56:15
results.m map where we get each individual file. And for each file,
6:56:21
we're going to return an LI, a list item. And else, if
6:56:26
we don't have any results, we can simply return a p tag with a class name equal
6:56:32
to empty-ash result. That's going to say no results or no files found. Let's make
6:56:40
sure to properly close everything. There we go. I think we're good. And now, what are we going to do
6:56:46
for each li? Well, first let's give it a key because we're mapping over it. So the key will be equal to file dot dollar
6:56:54
sign id. And let's make it render just the file.name to see if the search is
6:57:00
working. Would you look at that? We immediately get all the files because we
6:57:05
currently have no search query. But now if I type something like let's go with
6:57:11
white. Currently there's no way for us to modify that because it's never recalling this use effect. But if I
6:57:18
recall it every time that we change the query, the state of the query. And now
6:57:24
if I type white, you can see that it actually filters the correct files. But
6:57:29
we do have an error saying that the final argument passed to the use effect changed size between renders.
6:57:36
Interesting. So it means that the query got cleaned. But that should never be the case because it should always be a
6:57:42
string. So yeah, I think we're good now. And you can see that this search is fully functional. I'll show you how we
6:57:48
can improve it even further very soon. But for now, let's finish the UI of how we show each one of these because just
6:57:55
seeing a file name isn't really doing it justice. So let's give each LI a class
6:58:03
name equal to flex items center and justify dash between. Within an LI,
6:58:12
let's create another div that'll have a class name equal to flex
6:58:19
cursor-pointer items-c center and a gap of four. And within it, we can render a
6:58:26
thumbnail with a type of file. Extension equal to file.extension
6:58:33
extension URL equal to file URL and a class name equal to
6:58:41
size-9 and min-W9. If I close it here, this should
6:58:48
already look so much better because now we have great looking icons right here. Next, we can render this file name above
6:58:56
within the div, but let's wrap it in a P tag. So let me provide an opening and
6:59:02
closing p tag with a class name equal to
6:59:07
subtitle-2 line-clamp one so it fits in a single row and text-
6:59:17
light- looking much much better. Finally, right below this div, let's
6:59:23
also render the formatted date and time to which we can pass the date of file
6:59:30
dot dollar sign created at that's going to look something like
6:59:37
this. Let's properly close it. And let's also pass it a class name of
6:59:43
caption line dashclamp-1 and the text dash light of
6:59:49
200. There we go. So now we can see at least the time. And on large devices we
6:59:55
can see even the date alongside the full title. This is looking amazing. And
7:00:01
check this out. Even if I'm on images and I start typing something like let's go MP4. We can see all the MP4s or maybe
7:00:10
even we can see cinematic. Yep, this works as well. Now, if we click on it,
7:00:17
nothing really happens, does it? So, let's add a new function right here. And
7:00:23
let's call it const handle click item. Here, we're going to get a single
7:00:31
prop or param called file of a type models.doccument.
7:00:36
document and on click we want to set open is set to false. So we want to
7:00:42
close the model and we want to set result equal to an empty array and we
7:00:47
want to push to the page containing that file. For that we can use the router
7:00:53
functionality. So I'll say const router is equal to use
7:00:59
router. Let's make sure that we imported it from the right place. Next navigation. That's good. And now we can
7:01:07
say router.push and we want to go to forward slash file.type and if it is video then
7:01:16
we want to go to media. Else we want to go to file.type a string of s because if
7:01:24
it's image it's going to be images. If it's document it's going to be documents and so on. And then we want to give it a
7:01:31
question mark. query is equal to query. So we want to keep the search but we
7:01:37
want to navigate over to that specific page. So now that we have this handleclick item, let's actually pass it
7:01:43
over as a link click to the li by saying on click handleclick item and point to a
7:01:50
specific file. Now if I click living room furniture, it will close it and
7:01:56
point me to the images so I can find it very easily. Same thing if I go to
7:02:01
search and if I search for some kind of a document like a PDF, I click on it, it points me to
7:02:08
documents so I can find it. Same thing goes for videos and so on. Oh, it looks
7:02:15
like it didn't actually work with audios because it says audios. It should actually be just I think media or video.
7:02:23
So in that case we need to modify our query a bit saying if file type is video
7:02:30
or audio right because in those both cases it should go to media. So I'm just
7:02:36
going to duplicate this query and say file type is video or file type is
7:02:42
audio. Okay. And I'll wrap that in a parenthesy. In both cases it should
7:02:48
actually go to media. And it does seem that it is working right now. That is
7:02:54
great. Now we still have to properly close the search if there's nothing there. So we can say something like
7:03:02
right here at the top of the fetch files. If there is no
7:03:07
query in that case we can set results to be equal to an empty array and we can
7:03:13
set open to false and we can return router.push
7:03:19
push and we want to push to the same path but with no search query attached.
7:03:25
So let's get the current path by saying const path is equal to use path
7:03:31
name and then we can push to path.replace search
7:03:38
params to string with an empty string like this. So we're going to simply
7:03:45
nullify the search. If I reload and try searching for something, I'll try typing
7:03:50
cinematic. You can see it shows. I click on it, I get redirected. That works. But
7:03:56
if I clear the search, you can see all the other files and media. And everything works as expected. But now I
7:04:03
want to show you a big optimization that we can make with this search. And that
7:04:08
is implementing a concept known as debouncing. Why do we need the concept of
7:04:15
debouncing? Let me show you. If I search for something like
7:04:21
MP3, you see with every single keystroke as I was typing, it made another request
7:04:28
to the back end to the database. And as a user continues to type, it's making a
7:04:33
request for every single letter, which means that we're now overloading the database with these different requests.
7:04:41
Instead of doing that, what if we could not make a single request until the user
7:04:46
stops typing for a specific amount of time? Let's say maybe they continue typing and then they finish with the
7:04:53
word white and we send a single request to the database. Yep, that's possible.
7:04:59
We can do that by using the concept of debouncing. In our ultimate NexJS15
7:05:04
course, I dove deep into the concept of debouncing. I think it was right here on
7:05:09
their homepage. Implementing a local search bar. Check this out. Here we're
7:05:15
implementing a search bar to search through all of the questions of the stack orflow application. And we need to
7:05:22
really make it optimized. So first I show you how to implement it like we did in this case, but then we dive into
7:05:29
implementing the delay debounce function from scratch using callbacks and just
7:05:34
making sure that we don't overload our database. As you can see, this lesson on implementing this little search is about
7:05:41
36 minutes long. So here I make sure that we really go indepth with
7:05:46
explanations and implementations. So feel free to check out the course on
7:05:52
JSMY.pro. But with that said, even here I'll show you how to implement the debounce. In this case, we won't
7:05:59
implement it from scratch. We'll use the used debounce hook, a widely used hook
7:06:04
with more than 1.6 6 million weekly downloads. It is super simple to use. Let me show you. You can just run mpmi
7:06:12
use debounce-save. So, let me install it
7:06:17
right here by running that exact command. MPMI use-d debounce. And after
7:06:23
that, it is super simple to use. You just import use debounce from use
7:06:28
debounce at the top. After that, you need to call the hook and give the name to your debounced
7:06:35
value. So I'll do it something like this. I'll say const use
7:06:40
debounce. We want to debounce the field of query with a delay of 300
7:06:46
milliseconds. This means that the action will be only fired if a user hasn't entered another keystroke in the next
7:06:53
300 milliseconds. And here we can call it debounced query.
7:07:00
What I'll do now is simply replace the query with the debounce query in the use
7:07:07
effects dependency array. So we won't make a request whenever the query changes. We'll make a request whenever
7:07:13
the debounce query changes, which will only happen every 300
7:07:18
milliseconds max. But again, it might happen much less frequently if the user continues typing within that 300
7:07:25
millisecond time frame. Let's do a quick check to see if debounce
7:07:30
query.length is triple equal to zero. Then we want to reset everything. And
7:07:36
since we're checking the length, we don't need a exclamation mark right here. And instead of passing the query
7:07:43
to search text, we're going to pass a debounced query. Let's see if it's properly
7:07:49
accepting it. Search text right here. And it looks like it's expecting types
7:07:54
as well. So we can say types is an empty array because in this case we're doing a global search. We don't care about
7:08:00
filtering by types. We only care about searching. So if I go back now, if I
7:08:07
continue typing, you can see if I do it quickly, it will not make a single request. But as soon as I stop typing
7:08:14
for a second, only then will it make the request. So I can type out the entire
7:08:20
word of white and we only get the results after it has been typed out.
7:08:25
That's it with a global search and filtering based on types as well.
7:08:30
Everything works incredibly well. Now we have a very quick lesson next which is implementing the sort component. The
7:08:36
sort functionality is done but now we just want to implement a quick sort that looks something like this that allows
7:08:43
you to filter by name or maybe even the date. So let's do that next. I'll close
7:08:49
all the files and I'll drag my browser to the left to get started implementing the
7:08:56
sort component. Let's first install the chaten select component which will be of a great help. This is basically exactly
7:09:03
what we need. So let's install it by copying the installation command and
7:09:09
pasting it right here. mpx shaden at latest add select. let's say y and then
7:09:16
press enter and it's going to get installed. Once you do that, let's copy its
7:09:22
imports. And let's do it within the sort.tsx component. We already created
7:09:28
it, but we never implemented the logic. So, let me copy this here. And let me
7:09:33
also copy the usage of the select. I'll paste it right here. Fix this little
7:09:40
typo. Save it. And now if I go back and reload, you can see that we have a theme
7:09:46
selector. But a theme selector is not really what we want. Instead, we want to
7:09:51
be able to sort it. Okay. So let's make slight modifications. Let me first
7:09:57
access the router meaning the routing functionality by saying con router is equal to use router. And this use router
7:10:05
is coming from next navigation. Of course, if we're using the navigation,
7:10:10
we have to turn this into a use client component. Then we can declare a
7:10:15
function called handle sort which is equal to a function that accepts a value
7:10:21
of a type string. And then it can run the router.push and we're going to push to
7:10:29
we first have to get the existing path by saying const path is equal to use
7:10:34
path name coming from next navigation. So we're going to start our URL with a
7:10:40
path on which we're on. And then we're going to simply append to it a search param called sort which will be equal to
7:10:47
the value that we want to sort it with. Once we have that, let's give this select an on value change. And we can
7:10:54
call the handle sort right here. And let's also give it a default value which
7:11:00
will be equal to sort types which is going to come from constants zero.
7:11:08
If you take a look into the sort types, you can see that we have basically I think six different types. That's going
7:11:14
to be date created, newest, oldest, name, ascending, descending, and then
7:11:19
the size from highest to lowest. So once we have those, we can have a trigger to
7:11:25
which we can pass the class name equal to sort dash select.
7:11:32
And we have a select value to which we can pass the placeholder equal to sort
7:11:39
types zero dot value. So now we can see it says created at descending as a
7:11:46
placeholder value. After that we have the select content to which we can pass a class name equal to sort-
7:11:55
select-content and then within it we can map over all of the different select items. So let me simply say sort types
7:12:04
do map and then for each different sorting option we will simply return one
7:12:10
of these select items. I can remove the other two and we're going to of course
7:12:16
change how this select item behaves by giving it a key equal to sort label
7:12:22
because labels are unique. I'm going to give it a class name equal to shad-
7:12:29
select- item. And most importantly, we have to dynamically render the value,
7:12:34
which is going to be sort value. And within the select item, we can render the sort label. So the user knows what
7:12:42
they're selecting. If I do that, check this out. We have all of these different sorting options. And I actually want to
7:12:49
expand my browser for this. So you can see the full URL bar. I'll head over to
7:12:54
documents or no maybe media because we have the most media and let's try to sort it. Here we have it by date created
7:13:01
newest and currently the man strumming guitar is the last one based on date. So
7:13:07
let's switch it to oldest and it looks like nothing has happened. Oh wait, now
7:13:13
it switched it. So it seems like the first switch didn't actually work.
7:13:18
Interesting. Let's try one more time. I'll reload and select oldest. And then
7:13:24
I'll go back and switch to newest. And that worked. It's a bit tricky to check the dates right now because they're all
7:13:30
uploaded at a similar time. It might be a couple of milliseconds of a difference. But let's try switching it
7:13:36
by name. So if I say name A to Z, we can see that it starts with the letter C, it
7:13:42
moves to D, M, and P. So this is looking good. And if we do this one, it's
7:13:47
actually going the other way around. What about the size? This should be easy to check. We have 5.7 at the top, 1.9 at
7:13:54
the bottom. And if we switch it, that works. So, let me actually reload and
7:14:00
try to immediately switch it by the size. Yep, that works, too. Okay, so I think we're good. We can also check for
7:14:07
the images. Let me do it by size. Yep, that works. About created at works. Name
7:14:14
works as well. Wonderful. Believe it or not, it was that easy to implement the
7:14:20
sorting functionality on all of these different pages because we are reusing the same single sort component and it
7:14:28
doesn't have to do any extra logic besides simply modify the URL bar with a
7:14:33
new sort and then our file action for getting the files to which we
7:14:39
automatically pass the sort does the rest by modifying the queries if a sort
7:14:44
exists. Great work. But now that we have all of these things looking quite good,
7:14:51
what's going to happen with the dashboard? We kind of left it on its own for the time
7:14:57
being. To implement our dashboard, I prepared something quite special. See,
7:15:02
within our ultimate nextGS course, we often have something known as active
7:15:08
lessons. These are lessons which we specifically craft beforehand and give
7:15:13
you the task so you can develop something on your own. It doesn't just tell you what to build, but it goes into
7:15:19
the why and specifically how you can approach it. It contains examples,
7:15:26
resources, and heck, even a hint that is blurred out until you click it and decide that you need some help. So, as
7:15:33
you can see, they can get pretty big, and the NexJS course is full of them.
7:15:38
You can see for the database creation model, we have an active lesson for creating each one of these models in the
7:15:45
database starting from the task to the how to the additional resources and then
7:15:50
hints. Now, why am I telling you this? Well, first of all, because I'm proud of how well we created the nextgs course,
7:15:56
but the second reason is to show you that I have prepared an active lesson for you to build this dashboard off the
7:16:04
story project. Yep, there is a task. There is an example pointing to the
7:16:10
Figma link as well as all of the resources you might need and the implementation of how you can do it with
7:16:16
the data fetching chart components and even additional hints you can check out if you get stuck. As you can see, it's
7:16:24
pretty lengthy. So, take your time, don't rush it, really give it a go and
7:16:29
trust the process. So, in this case, we won't be doing it together. I want you to take what we have right now, the
7:16:36
entire codebase, see if you can figure out the bits and pieces of how it works, the file and folder structure, where you
7:16:43
can add additional server actions if you need to, and where you would actually implement the dashboard. Of course, it
7:16:50
would go into the root and then page where we currently only have this homepage. Of course, the final repo
7:16:56
containing the full code will be linked down below, but for now, I'll show you how it should look like. As you can see,
7:17:02
it's going to be about a 100 line long page where we basically get all the
7:17:07
files using the same server action we have created before, but we're using a little bit of an optimization here by
7:17:14
using parallel data fetching. We're fetching both the total space as well as
7:17:20
the files. And since one doesn't depend on the other, we can fetch them at the same time, effectively making the load
7:17:26
time two times faster than it would usually be. Of course, to make this happen, we also have to create some
7:17:32
additional actions. And that's basically one single action in the file actions file. So, let's scroll to the bottom of
7:17:39
it where I hope you implemented it. Of course, your naming doesn't have to be the same as it is in my case. But
7:17:46
basically, I called it get total space used. And in this case, it uses the create session client. So, we have to
7:17:53
import it. And I switch this over right here. So, there's no errors. And I believe this is it. Let's see what else
7:17:59
do we need. We need to get a thumbnail from the components thumbnail which we already created but we also have to
7:18:05
export it by adding the export to it. We have the formatted date and time which
7:18:11
we also already created but forgot to export. And finally we're using the actions dropdown but I think in my
7:18:17
version of the codebase I called it action dropdown. So we can just fix the naming right here and then import it
7:18:24
right here at the bottom. And in our case, it's not a named import, it's a default import. So we can do it just
7:18:31
like this. And finally, we have to install shaden charts. So I'll say mpx
7:18:37
shaden add latest add chart. And immediately it'll be installed. And you
7:18:43
can see that this red squiggly line will remain there because this chart component is not a shaden component. It
7:18:49
is actually an additional chart that we need to create that then uses the shadian charts. So, let's head over to
7:18:56
the components and create the last component of the day. I'll call it
7:19:01
chart.tsx. And you can find the code either in the active lesson or if it's
7:19:06
not there, it's going to be in the final repo. Chart.tsx. If you do that, let's close
7:19:12
the files and reopen the homepage one more time. Oh, it looks like this red squiggly line didn't get removed even
7:19:18
though we're properly importing the chart from the chart page. Oh, I think it's gone. So, I think we're good. And
7:19:24
with that, if we go back here, check this out. We have the available storage, only 40 megabytes out of 2 GB in total
7:19:32
available. We can see how much of each specific file type we have. And we can
7:19:37
also see a list of recent files uploaded. And we can immediately perform
7:19:42
actions on all of them directly from the dashboard. Now, this is looking like a
7:19:48
real storage management solution. So, how did you like it? I hope this active lesson gave you enough info for you to
7:19:55
be able to build it on your own. But if not, I hope you were able to take some pieces of the puzzle of the full
7:20:00
solution and then just put them all together. Let me know whether you like me to include more active lessons like
7:20:06
this or if this was too hard. And as I said before, if you enjoy this active
7:20:11
lesson and you want more hands-on practice, check out the Ultimate Nex.js course. More than 50 interactive lessons
7:20:18
available. And once again, if you experience any issues while developing it, just make sure to go to the GitHub
7:20:25
repo of this project and refer to it. Knowing how to read and use other
7:20:31
people's code bases is crucial for growing as a developer. So, if you can't do that effectively, you'll have to
7:20:37
improve there. So, even if you didn't complete it on your own successfully, make sure to patch it all together so it
7:20:43
works like it does in my end right here. By putting this page.tsx tsx together as well as the chart component and file
7:20:51
actions like get total space used. And with that said, we are ready to focus on
7:20:56
the deployment. To get our project deployed, as with all the other great NexJS
7:21:03
projects, we first have to push it over to GitHub. So head over to github.com
7:21:08
and create a new repo. Let's call it something like storage management solution or you can call it
7:21:16
store it or whatever name you prefer. Create a repo. Now we'll have to follow these commands within our editor.
7:21:24
So let's open up the terminal. Stop it from running and then run git init to
7:21:32
initialize an empty repo within this project. Now, when I was deploying this project before, I encountered some
7:21:40
errors. So, I know how to fix them before they happen. So, let me show you. The error I experienced was this one
7:21:48
saying route forward slash couldn't be rendered statically because it used the
7:21:54
cookies functionality. So, that means that it requires dynamic server usage.
7:22:00
So, how would you go about fixing something like this? Well, the solution is pretty simple. Let's head over to
7:22:08
layout.tsx of the root and right at the top of that file, add a new export const
7:22:16
dynamic and make it equal to force-ashd dynamic. Now, why are we doing this?
7:22:23
Well, that's because Nex.js says that this page couldn't be rendered statically as it uses the cookies. That
7:22:31
means that the page or component you're trying to render relies on data from cookies which requires dynamic behavior.
7:22:38
Static pages are pre-rendered at buildtime and cannot use runtime specific features like the cookies which
7:22:45
are only available at request time. So setting this export cons dynamic to force dynamic will make the page render
7:22:53
on the server for each request which is not the same as client side rendering. Now let's follow the next steps for
7:22:59
pushing a repo to GitHub. I'll run git add dot to add all the files. git
7:23:07
commit-m first commit get branch- m main
7:23:12
get remote add origin and then the link to this page. But it looks like I pushed
7:23:18
before. So I'll have to actually change it to origin one. And finally get push u
7:23:25
origin main. If you do that and go back to GitHub and reload, you can now see
7:23:31
your codebase appear right here. We needed to do that for Versel to
7:23:36
recognize it. As you can see, I'm using Verscell to host all of my projects, even our great course platform. But now,
7:23:43
head over to add a new project, and it should be right here at the top. Added
7:23:48
about 48 seconds ago. So, just import it. Storage management solution. And it's going to ask you to
7:23:55
add environment variables. So going back to our project and heading over to enenv.local, there's
7:24:02
a little trick that you can do, which is just copy everything from this file and then paste it in this first input. This
7:24:10
will automatically populate all of the other key and value pairs. Once you do that, don't deploy just yet. I
7:24:17
remembered that we might have one or two Typescript errors left or even eslint
7:24:23
errors left which are not really errors if you think about it but they could potentially disallow us from building
7:24:29
this project on Verscell even though I'm trying to find some of them and it looks like we've been paying very good
7:24:35
attention to remove all of these TypeScript type errors and ESLint errors. So, you know what? Let's give it
7:24:40
a shot. If it doesn't work, we can just try to maybe suppress the warnings just so the build goes through. But who
7:24:46
knows, maybe we did a phenomenal job and the codebase is squeaky clean. With that
7:24:52
said, let's go ahead and deploy it. And fingers crossed, hope for the best. About 56 seconds have passed and we seem
7:24:59
to have an error in the build log. Was I right? Yep, I was right. We did leave
7:25:05
just some unused variables in the mobile navigation. But other than that, our codebase was very well done. So, what I
7:25:12
will do is head over to mobile navigation to quickly remove those
7:25:18
unused variables. As you can see, it's just two lines right here, which are not breaking anything, but again, TypeScript
7:25:25
and ESLint don't like them. And I'll head over to next.config.ts and then say
7:25:33
TypeScript and then add ignore build errors to true. And I'll do the same thing for
7:25:39
eslint by saying ignore during builds is set to true. Now if we make a push by
7:25:46
saying get add dot get commit dash ignore build errors and then get
7:25:54
push. If you go back to versel specifically to your projects click on
7:25:59
that project and go to deployments you can see that another deployment is being built. Let's see how this one goes. And
7:26:07
there we go. The build is built. You can see it also populated our favicon right
7:26:12
here at the top. So head over to project and click visit at the top
7:26:18
right. You'll be able to see that we have an application error. A serverside exception has occurred. And this seems
7:26:26
to be happening on our homepage. And I'm actually super glad that this happened because I want to teach you how to debug
7:26:33
it. Deployment errors are common and you need to know how to fix them. So if you
7:26:38
head over to inspect element and go to the console, you'll notice that you have some kind of an error message. But let's
7:26:44
see if it's useful. It says error. An error occurred in the server components
7:26:49
render. The specific message is omitted in production builds to avoid leaking
7:26:55
sensitive details. A digest property is included on this error instance which may provide additional value about the
7:27:02
nature of the error but again doesn't give us a lot of info. So how do you debug server errors if you no longer
7:27:09
have a terminal? It's pretty simple. You head over to Verscell, you go to logs and
7:27:16
then right here you can find more details about the error. In this case we get an error no session coming from root
7:27:23
page. So let's go ahead and console log the no session thing because it does
7:27:29
appear to be something that we wrote. So if I search for no session, you can see that it only occurs a single time within
7:27:37
our entire codebase. So that's already a good sign. It occurs when we're trying to create a session client. But when are
7:27:45
we trying to call this from the homepage? Let's see if I head over to page root right here. And then you can
7:27:52
see that we're not really calling that create client. But if you head over to
7:27:58
the layout of the root, you'll notice that we're calling the get current user the first thing ever. And right here
7:28:05
within it, we're calling the create session client, which then throws an error in case there's no active session,
7:28:12
which makes sense, right? Because we cannot have a session if a user hasn't logged in yet. So the only thing you
7:28:18
have to do is wrap the get current user in a try and catch block like this. In
7:28:26
the catch we of course get access to the error and we can maybe just console log the error. But we have to pull
7:28:32
everything else into the try block. So we actually catch an error if we throw
7:28:38
it from the create session client. And you can see here that we say if user total is lower than or equal to zero
7:28:44
return null which is totally okay. So right here we're going to return null
7:28:50
not throw an error and then if we don't have a user we will redirect to sign in.
7:28:55
Now let's go ahead and push those changes to our repo by saying get add dot getit
7:29:00
commit-fix deployment. That's a common one. And then finally get push. If you
7:29:07
do that you can head over to your deployment and let's wait for the new build to go through and hopefully that
7:29:14
fixes the issue. And there we go. Our deployment is live and ready. We already
7:29:19
knew that's going to happen. But is it actually working? If I visit our storage
7:29:25
management deploy solution and try to sign in with the email that I used before, or you can also create a new
7:29:31
account. That's totally up to you. We should get an OTP verification model
7:29:36
which just arrived to my email inbox. It's
7:29:41
681565. Press enter or submit. And immediately we are redirected to our
7:29:47
beautiful looking dashboard. I mean this is just amazing. It's a it's a very detailed application with a lot of
7:29:53
moving parts. I truly hope you enjoyed the build. We got a chance to learn a lot about file management while of
7:30:00
course using the latest and greatest best practices from Nex.js to make sure that all of this loads super quickly. So
7:30:08
if you'd like this free course, imagine what we'll do in the ultimate Nex.js GS course. I mean, here we're going to dive
7:30:16
into a lot of depth, teaching you how to use Nex.js the right way. From hydration error fixes to stale data to even
7:30:23
caching and different runtimes. There's a lot of stuff we'll cover. And of course, you'll improve your performance,
7:30:30
dive deep into server and client components, use the latest React and Nex.js
7:30:35
features, and more. All with deep dive lessons which are illustrated theory
7:30:41
lessons to teach you the baseline. Then we build and deploy a very complex app.
7:30:46
And then as I told you, we have those active lessons which really dive in depth teaching you how you can create
7:30:52
some stuff on your own. How many times has that budget